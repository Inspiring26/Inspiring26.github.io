<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[python逐行读取]]></title>
    <url>%2F2020%2F12%2F15%2Fpython%E9%80%90%E8%A1%8C%E8%AF%BB%E5%8F%96%2F</url>
    <content type="text"><![CDATA[逐行读取可以循环使用到文件末尾是返回的是空字符串即使到文字末尾了依然可以循环调用，不会报错print的技巧当你想看具体的输出结果时，在结果外加上方括号就可以了。 补充 只要在读取的时候判断是否为空，最后多出一个空行不影响的，毕竟最后一行没有换行号。]]></content>
      <tags>
        <tag>方法</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[备案问题，域名实名认证信息与备案主体不一致]]></title>
    <url>%2F2020%2F12%2F15%2F%E5%A4%87%E6%A1%88%E9%97%AE%E9%A2%98%EF%BC%8C%E5%9F%9F%E5%90%8D%E5%AE%9E%E5%90%8D%E8%AE%A4%E8%AF%81%E4%BF%A1%E6%81%AF%E4%B8%8E%E5%A4%87%E6%A1%88%E4%B8%BB%E4%BD%93%E4%B8%8D%E4%B8%80%E8%87%B4%2F</url>
    <content type="text"><![CDATA[我在腾讯云买的域名，并做了实名认证。服务器在阿里云，在阿里云作备案时提示域名实名认证和备案主体不一致。 解决方法首先核对一下域名认证的实名信息，包括拼音的大小写都要一致。然后等个2~5天再提交就可以了。之所以要好几天，感觉是腾讯阿里间不好好配合。]]></content>
      <tags>
        <tag>方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派及其他linux系统查看位数]]></title>
    <url>%2F2020%2F12%2F11%2F%E6%A0%91%E8%8E%93%E6%B4%BE%E5%8F%8A%E5%85%B6%E4%BB%96linux%E7%B3%BB%E7%BB%9F%E6%9F%A5%E7%9C%8B%E4%BD%8D%E6%95%B0%2F</url>
    <content type="text"><![CDATA[1getconf LONG_BIT 这个简单的命令，可以记住了getconf LONG_BIT]]></content>
      <tags>
        <tag>linux</tag>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[aliyun上传下载带宽]]></title>
    <url>%2F2020%2F12%2F11%2Faliyun%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E5%B8%A6%E5%AE%BD%2F</url>
    <content type="text"><![CDATA[我开的是1Mbps带宽的VPS，自己搭的下载服务，下载速度在130k/s左右；scp上传的速度固定在2.0MB/s。就是说如果作为后台使用，传入数据需控制在2M/s以内，以仅传压缩字符串为例：123&#123; &quot;info&quot;:&quot;7c3146c32a3d8ac8c46bd97d014049183487bd6e.ADF1604288936AAA&quot;&#125;body 占74b加上header共占336b如果这么传信息可以做到6~7千的并发 而下载的130k/s几乎不可用，连一个图片都不能传。 更新用公司电脑和家里树莓派同时测试上传一个在2.0MB/s 一个在2.8MB/s，结合论坛资料，阿里云上传带宽是不限制的，可以到达10M/s~20M/s。 提升带宽费用过高，稍后测试反向代理树莓派的方式进行下载。]]></content>
      <tags>
        <tag>alinyun</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[歌曲分享1]]></title>
    <url>%2F2020%2F11%2F25%2F%E6%AD%8C%E6%9B%B2%E5%88%86%E4%BA%AB1%2F</url>
    <content type="text"><![CDATA[今天发现了两首挺好听的歌。一首是田馥甄的《一一》一首是司南的《冬眠》]]></content>
      <tags>
        <tag>歌曲分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[word、excel等office文件内容提取及预览的方法]]></title>
    <url>%2F2020%2F11%2F25%2Fword%E3%80%81excel%E7%AD%89office%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E6%8F%90%E5%8F%96%E5%8F%8A%E9%A2%84%E8%A7%88%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[预览预览而不下载的方法就是，转换为pdf，点击时将pdf不作为附件。这时就会新打开一个预览页面。提取在windows服务器上，以前使用的时office自带的接口进行转换，转换后用pdfminer提取内容作为简介。部署到linux系统上可以使用libreoffice转换。但是转换后再用pdfminer提取会出现同一个字的大量重复。 linux下用wps转换不成，突然想到的一个效果很好的方法分析问题：之所以出现pdfminer提取乱码，是因为用的不是word转换的。解决方法：上传的是pdf格式的，一般是别人用word转换好的，直接提取不会出现什么问题，那种确实不能提取的除非ocr识别，可以不管。上传的是word、excel、ppt等格式的，可以将转换展示和内容提取分开。转换展示，即使用libreoffice转换为pdf后展示。内容提取可以将文件转换成txt文件,word里有一个另存为txt的选项，这样就可以非常完整的提取到word的内容。 总结原路几乎走不通的问题，换个思路就完整高效的解决了。遇到问题了，唯有转化、转化、转化，这也是我从《数学之美》里获得的收获。]]></content>
      <tags>
        <tag>方法</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim常用指令]]></title>
    <url>%2F2020%2F11%2F25%2Fvim%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[定位12G&#x2F;1G&#x2F;gg 最后一行&#x2F;第一行&#x2F;第一行w&#x2F;b 下一个单词&#x2F;前一个单词编辑/插入12i&#x2F;I&#x2F;a&#x2F;A 光标字符前插入&#x2F;行首插入&#x2F;光标之后插入&#x2F;行尾插入$&#x2F;^ 仅移动光标不编辑的行尾&#x2F;行首 删除/复制/粘贴123dd&#x2F;ndd 删除当前行&#x2F;删除当前行开始的n行yy&#x2F;nyy 复制当前行&#x2F;复制当前行开始的n行p 粘贴 查找1&#x2F;word 斜杠加单词就开始查找，回车后n下一个，N反方向下一个 替换12345678910:%s&#x2F;word1&#x2F;word2&#x2F;gc :s 当前行:%s 全文:6,10s 6到10行:.,+2s 当前行加后面两行常用的是:%s :s不加后面的&#x2F;g表示只替换后面的一个这个位置可以有g(全部)、i(大小写不敏感)、I（大小写敏感）、c（需要确认） 定位或查找后新开一行1o&#x2F;O o在下面开一行&#x2F;O在上面开一行 查看具体指令的文档12:help word 查询指令用法:q 返回之前编辑的文件 plan接下来一个月把编辑器转到vim。]]></content>
      <tags>
        <tag>方法</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux将内容移出交换区或开关交换区]]></title>
    <url>%2F2020%2F11%2F23%2Flinux%E5%B0%86%E5%86%85%E5%AE%B9%E7%A7%BB%E5%87%BA%E4%BA%A4%E6%8D%A2%E5%8C%BA%E6%88%96%E5%BC%80%E5%85%B3%E4%BA%A4%E6%8D%A2%E5%8C%BA%2F</url>
    <content type="text"><![CDATA[123456789# 查看交换区文件➜ h2 swaponNAME TYPE SIZE USED PRIO&#x2F;swapfile file 2G 729.6M -2# 关闭所有的➜ h2 swapoff -a# 挂载指定的交换文件➜ h2 swapon &#x2F;swapfile ➜ h2]]></content>
      <tags>
        <tag>方法</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[查看当前使用的是哪个shell]]></title>
    <url>%2F2020%2F11%2F19%2F%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E4%BD%BF%E7%94%A8%E7%9A%84%E6%98%AF%E5%93%AA%E4%B8%AAshell%2F</url>
    <content type="text"><![CDATA[查看是bash还是zsh等1echo $0]]></content>
      <tags>
        <tag>方法</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux卸载oh_my_zsh]]></title>
    <url>%2F2020%2F11%2F19%2Flinux%E5%8D%B8%E8%BD%BDoh-my-zsh%2F</url>
    <content type="text"><![CDATA[卸载12345678➜ ~ uninstall_oh_my_zshAre you sure you want to remove Oh My Zsh? [y&#x2F;N] yRemoving ~&#x2F;.oh-my-zshLooking for original zsh config...Switching your shell back to &#39;&#x2F;bin&#x2F;bash&#39;:Password: Thanks for trying out Oh My Zsh. It&#39;s been uninstalled.Don&#39;t forget to restart your terminal! 切换or not1sudo chsh -s &#x2F;bin&#x2F;bash]]></content>
      <tags>
        <tag>方法</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大概是最简单的生成日期列表及获得今天日期代码]]></title>
    <url>%2F2020%2F10%2F28%2F%E5%A4%A7%E6%A6%82%E6%98%AF%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E7%94%9F%E6%88%90%E6%97%A5%E6%9C%9F%E5%88%97%E8%A1%A8%E5%8F%8A%E8%8E%B7%E5%BE%97%E4%BB%8A%E5%A4%A9%E6%97%A5%E6%9C%9F%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[生成日期列表12# closed根据需要，可加可不加。[_.strftime(&quot;%Y%m%d&quot;) for _ in pd.date_range(start&#x3D;&#39;2020-09-02&#39;, end&#x3D;&#39;2020-10-28&#39;, closed&#x3D;&#39;left&#39;)] 获取今天日期123&gt;&gt;&gt; from datetime import date&gt;&gt;&gt; date.today().strftime(&quot;%Y%m%d&quot;)&#39;20201028&#39;]]></content>
      <tags>
        <tag>方法</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pytorch将张量加载到gpu显存时，cpu内存会增加2G左右]]></title>
    <url>%2F2020%2F09%2F27%2Fpytorch%E5%B0%86%E5%BC%A0%E9%87%8F%E5%8A%A0%E8%BD%BD%E5%88%B0gpu%E6%98%BE%E5%AD%98%E6%97%B6%EF%BC%8Ccpu%E5%86%85%E5%AD%98%E4%BC%9A%E5%A2%9E%E5%8A%A02G%E5%B7%A6%E5%8F%B3%2F</url>
    <content type="text"><![CDATA[第一次将张量等转移到gpu时，cpu内存会增加2G，这是正常现象，是cuda和pytorch初始化共同导致的。同一个程序只有第一次操作时会增加。更多信息参考pytorch的issues地址]]></content>
      <tags>
        <tag>pytorch</tag>
        <tag>分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pytorch损失函数会导致显存不断增长的问题]]></title>
    <url>%2F2020%2F09%2F27%2Fpytorch%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E4%BC%9A%E5%AF%BC%E8%87%B4%E6%98%BE%E5%AD%98%E4%B8%8D%E6%96%AD%E5%A2%9E%E9%95%BF%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[分析如果已经把模型和变量放到显存中了，每个epoch计算的损失值也是在显存中的，即.cuda()的类型。如果我们计算总损失的变量是.cpu()类型的，每次迭代的时候计算到的的.cuda()格式变量是不会释放的，从而会导致显存不断增加。 解决方法1.转换为.cpu()再累加实际代码并不难使用.cpu(),而是.item()1234567loss &#x3D; criterion(labels,outputs).item()totalloss+&#x3D;loss或loss &#x3D; criterion(labels,outputs)totalloss+&#x3D;loss.item()如果使用.cpu(),只是在内存中生成了一份，显存中的并未释放。2.声明.cuda()变量]]></content>
      <tags>
        <tag>方法</tag>
        <tag>pytorch</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pandas]]></title>
    <url>%2F2020%2F09%2F23%2Fpandas%2F</url>
    <content type="text"><![CDATA[在做这个推荐系统的过程中，能用新方法的绝不用老方法，处理excel技术大大提升了。如果是现在给皮皮处理excel，一定溜的飞起。。。]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python装饰器]]></title>
    <url>%2F2020%2F09%2F23%2Fpython%E8%A3%85%E9%A5%B0%E5%99%A8%2F</url>
    <content type="text"><![CDATA[装饰器123456789101112131415def foo(): print &#39;in foo()&#39; # 定义一个计时器，传入一个，并返回另一个附加了计时功能的方法 def timeit(func): # 定义一个内嵌的包装函数，给传入的函数加上计时功能的包装 def wrapper(): start &#x3D; time.clock() func() end &#x3D;time.clock() print &#39;Time Elapsed:&#39;, end - start # 将包装后的函数返回 return wrapper的实际使用是1foo &#x3D; timeit(foo)简写为12@timeitdef foo()很好理解：新foo等于12345def wrapper(): start &#x3D; time.clock() foo() # 原foo()函数 end &#x3D;time.clock() print &#39;Time Elapsed:&#39;, end - start 总结就是经过装饰器，把原函数传到新函数了。在新函数中又定义了一个嵌套函数，其实最终返回的结果就是这个嵌套函数。]]></content>
      <tags>
        <tag>总结</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python多进程]]></title>
    <url>%2F2020%2F09%2F23%2Fpython%E5%A4%9A%E8%BF%9B%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[简单粗暴的方法1234567f1 &#x3D; Process(target&#x3D;func1,args&#x3D;(q1res,))f2 &#x3D; Process(target&#x3D;func2,args&#x3D;(q2res,))f1.start()f2.start()f1.join()f2.join() 简单处理多进程12345678910ps&#x3D;[]for i in [fanca, funcb] p&#x3D;Process(target&#x3D;i) ps.append(p)for i in range(2): ps[i].start()for i in range(2): ps[i].join() 使用进程池处理多进程12345ps &#x3D; Pool(3)for p in [write_showDF, write_clickDF, write_textLinks]: ps.apply(p)ps.close()ps.join() 进程间通信以第一种形式，且子进程间无交互为例12345678910q1res &#x3D; mp.Queue()q2res &#x3D; mp.Queue()f1 &#x3D; Process(target&#x3D;func1,args&#x3D;(q1res,))f2 &#x3D; Process(target&#x3D;func2,args&#x3D;(q2res,))f1.start()f2.start()f1.join()f2.join()rec_cec_df,norm_cec_df&#x3D;q1res.get(),q2res.get()]]></content>
      <tags>
        <tag>总结</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python官方命名规范简单总结]]></title>
    <url>%2F2020%2F09%2F15%2Fpython%E5%AE%98%E6%96%B9%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[1.不加分号2.每行不超过80个字符所有语句都是可以换行的圆括号、中括号、花括号中的行是隐式连接起来的3.顶级定义之间空两行，方法之间空一行4.每个导入单独占一行5.命名(1)除计数器、迭代器不使用单字符(2)不使用-(3)通常不使用__开头或结尾(4)类名使用大驼峰(5)模块名(函数名)使用小写加下划线(6)变量名和函数名一样，小写加下划线 参考地址python-style-guide]]></content>
      <tags>
        <tag>总结</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不要温和地走进那个良夜]]></title>
    <url>%2F2020%2F09%2F03%2F%E4%B8%8D%E8%A6%81%E6%B8%A9%E5%92%8C%E5%9C%B0%E8%B5%B0%E8%BF%9B%E9%82%A3%E4%B8%AA%E8%89%AF%E5%A4%9C%2F</url>
    <content type="text"><![CDATA[不要温和地走进那个良夜，白昼将尽，暮年仍应燃烧咆哮，怒斥吧，怒斥，怒斥那光的消逝。虽在白昼尽头，智者自知该踏上征途 不要温和地走进那个良夜不要静候命运的安排]]></content>
  </entry>
  <entry>
    <title><![CDATA[oh_my_zsh下查看当前是不是root权限]]></title>
    <url>%2F2020%2F09%2F03%2Foh-my-zsh%E4%B8%8B%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E6%98%AF%E4%B8%8D%E6%98%AFroot%E6%9D%83%E9%99%90%2F</url>
    <content type="text"><![CDATA[123456➜ ~ whoamih➜ ~ sudo su[sudo] password for h: h-B360M-D2VX-SI# whoamiroot]]></content>
      <tags>
        <tag>方法</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jupyter卸载其他核心]]></title>
    <url>%2F2020%2F09%2F02%2Fjupyter%E5%8D%B8%E8%BD%BD%E5%85%B6%E4%BB%96%E6%A0%B8%E5%BF%83%2F</url>
    <content type="text"><![CDATA[查看1234➜ ~ jupyter kernelspec listAvailable kernels: javascript &#x2F;home&#x2F;h&#x2F;.local&#x2F;share&#x2F;jupyter&#x2F;kernels&#x2F;javascript python3 &#x2F;home&#x2F;h&#x2F;.local&#x2F;share&#x2F;jupyter&#x2F;kernels&#x2F;python3 卸载12345➜ ~ jupyter kernelspec remove javascriptKernel specs to remove: javascript &#x2F;home&#x2F;h&#x2F;.local&#x2F;share&#x2F;jupyter&#x2F;kernels&#x2F;javascriptRemove 1 kernel specs [y&#x2F;N]: y[RemoveKernelSpec] Removed &#x2F;home&#x2F;h&#x2F;.local&#x2F;share&#x2F;jupyter&#x2F;kernels&#x2F;javascript]]></content>
      <tags>
        <tag>方法</tag>
        <tag>jupyter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[golang、gin小知识点]]></title>
    <url>%2F2020%2F09%2F01%2Fgolang%E3%80%81gin%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[gin中常见的gin.H实际就是map[string]interface{}所以给网页传递变量的12345router.GET(&quot;&#x2F;index&quot;, func(c *gin.Context) &#123; c.HTML(http.StatusOK, &quot;index.tmpl&quot;, gin.H&#123; &quot;title&quot;: &quot;Main website&quot;, &#125;) &#125;)就可以替换为123router.GET(&quot;&#x2F;rec&quot;, func(c *gin.Context) &#123; c.HTML(http.StatusOK, &quot;index.tmpl&quot;, province_text_dict) &#125;) 接着上面讲如何讲interface{}转换为具体类型假设value为interface{}类型value.(type)可查看其类型如果是string类型，value.(string)即可转换类型为string。前提是要准确知道类型。]]></content>
      <tags>
        <tag>方法</tag>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python生成式]]></title>
    <url>%2F2020%2F08%2F31%2Fpython%E7%94%9F%E6%88%90%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1. 并列for循环其实是嵌套for循环12&gt;&gt;&gt; [m + n for m in &#39;ABC&#39; for n in &#39;XYZ&#39;][&#39;AX&#39;, &#39;AY&#39;, &#39;AZ&#39;, &#39;BX&#39;, &#39;BY&#39;, &#39;BZ&#39;, &#39;CX&#39;, &#39;CY&#39;, &#39;CZ&#39;] 2.if…elseif可以在for语句之前，也可以在for语句之后在for语句之后，if是个筛选条件，不能加else。在for语句之前的部分是表达式，形如11 if 2％2&#x3D;&#x3D;0 else 0本来就是一个表达式。 总结：for语句之前是表达式，之后可加判断条件，仅限if，运行顺序是for—>for后判断—>(通过判断才运行表达式)]]></content>
      <tags>
        <tag>方法</tag>
        <tag>总结</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python虚拟环境简单使用]]></title>
    <url>%2F2020%2F08%2F20%2Fpython%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[安装virtualenv1pip3 install virtualenv查看版本1virtualenv --version如果版本大于20，默认不复制系统库进入项目文件夹，创建虚拟环境1virtualenv venv 进入环境1source venv&#x2F;bin&#x2F;activate 完成使用后退出虚拟环境1deactivate 老博客地址：https://www.jianshu.com/u/1c73a3a8ae2d新博客地址：https://inspiring26.github.io/]]></content>
      <tags>
        <tag>方法</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu升级cuda、cudnn]]></title>
    <url>%2F2020%2F07%2F24%2Fubuntu%E5%8D%87%E7%BA%A7cuda%E3%80%81cudnn%2F</url>
    <content type="text"><![CDATA[升级python大版本后，需要重新安装多个库，包括pytorch相关的库。1.查看已有的cuda1ls &#x2F;usr&#x2F;local&#x2F;cuda*cuda是带版本号cuda的软链2.使用bin目录下自带脚本卸载 1sudo &#x2F;usr&#x2F;local&#x2F;cuda&#x2F;bin&#x2F;uninstall_*.pl 3.删除剩余文件12ls &#x2F;usr&#x2F;local&#x2F;cuda*sudo rm -rf &#x2F;usr&#x2F;local&#x2F;cuda* 4.下载对应版本cuda、cudnn，注意是对应不是最新123456# cuda toolkit 下载run文件https:&#x2F;&#x2F;developer.nvidia.com&#x2F;cuda-toolkit-archive# cuDNNhttps:&#x2F;&#x2F;developer.nvidia.com&#x2F;rdp&#x2F;cudnn-archive# 同时参考pytorch的版本要求https:&#x2F;&#x2F;pytorch.org&#x2F;get-started&#x2F;locally&#x2F; 5.安装cuda12# 通常除了驱动都安装sudo sh cuda_*_linux.run 6.修改环境变量12345# vim ~&#x2F;.bashrcexport LD_LIBRARY_PATH&#x3D;$LD_LIBRARY_PATH:&#x2F;usr&#x2F;local&#x2F;cuda&#x2F;lib64export PATH&#x3D;$PATH:&#x2F;usr&#x2F;local&#x2F;cuda&#x2F;binexport CUDA_HOME&#x3D;$CUDA_HOME:&#x2F;usr&#x2F;local&#x2F;cuda 有软链直接修改成cuda就可以了，不用加版本号 7.升级cudnn12345678910tar -zxvf cudnn*.tgzsudo cp include&#x2F;cudnn.h &#x2F;usr&#x2F;local&#x2F;cuda&#x2F;include&#x2F;sudo cp lib64&#x2F;lib* &#x2F;usr&#x2F;local&#x2F;cuda&#x2F;lib64&#x2F;# 在新文件夹建立软链cd &#x2F;usr&#x2F;local&#x2F;cuda&#x2F;lib64&#x2F;sudo chmod +r libcudnn.so.7.0.5sudo ln -sf libcudnn.so.7.0.5 libcudnn.so.7 sudo ln -sf libcudnn.so.7 libcudnn.so sudo ldconfig 8.OVER]]></content>
      <tags>
        <tag>方法</tag>
        <tag>cuda</tag>
        <tag>ubuntu</tag>
        <tag>cudnn</tag>
        <tag>升级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu升级python版本详细流程]]></title>
    <url>%2F2020%2F07%2F23%2Fubuntu%E5%8D%87%E7%BA%A7python%E7%89%88%E6%9C%AC%E8%AF%A6%E7%BB%86%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[本方法使用的是apt安装1.搜索ppa,找到可用的源2.在launchpad.net里搜索python33.建议找到一个叫Jonathon F的用户，他编译的包比较可靠。可以进入他的主页找到他发布的python的各个版本。4.以python3.8为例，打开对应页面5.里面有这样的添加ppa的指令12sudo add-apt-repository ppa:jonathonf&#x2F;python-3.8sudo apt-get update 6.添加、更新完后安装1sudo apt install python3.8 7.查看目前有的python版本12345678910$ ls &#x2F;usr&#x2F;bin&#x2F;pytho*&#x2F;usr&#x2F;bin&#x2F;python &#x2F;usr&#x2F;bin&#x2F;python3.6&#x2F;usr&#x2F;bin&#x2F;python2 &#x2F;usr&#x2F;bin&#x2F;python3.6-config&#x2F;usr&#x2F;bin&#x2F;python2.7 &#x2F;usr&#x2F;bin&#x2F;python3.6m&#x2F;usr&#x2F;bin&#x2F;python2.7-config &#x2F;usr&#x2F;bin&#x2F;python3.6m-config&#x2F;usr&#x2F;bin&#x2F;python2-config &#x2F;usr&#x2F;bin&#x2F;python3.8&#x2F;usr&#x2F;bin&#x2F;python2-jsonschema &#x2F;usr&#x2F;bin&#x2F;python3-config&#x2F;usr&#x2F;bin&#x2F;python2-pbr &#x2F;usr&#x2F;bin&#x2F;python3m&#x2F;usr&#x2F;bin&#x2F;python2-wsdump &#x2F;usr&#x2F;bin&#x2F;python3m-config&#x2F;usr&#x2F;bin&#x2F;python3 &#x2F;usr&#x2F;bin&#x2F;python-config 8.删除老版本1sudo rm &#x2F;usr&#x2F;bin&#x2F;python3.6 9.删除原来的软链接1sudo rm &#x2F;usr&#x2F;bin&#x2F;python3 10.创建新的软链接1sudo ln -s &#x2F;usr&#x2F;bin&#x2F;python3.8 &#x2F;usr&#x2F;bin&#x2F;python3 11.可能需要重新安装pip12wget https:&#x2F;&#x2F;bootstrap.pypa.io&#x2F;get-pip.py --no-check-certificatesudo python3 get-pip.py 12.pip3 list 会发现有很多库消失了，需要重新安装，且还在的很多需要安装cp38版。OVER]]></content>
      <tags>
        <tag>方法</tag>
        <tag>ubuntu</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chrome插件网页便利贴导致无法选中文字]]></title>
    <url>%2F2020%2F07%2F21%2Fchrome%E6%8F%92%E4%BB%B6%E7%BD%91%E9%A1%B5%E4%BE%BF%E5%88%A9%E8%B4%B4%E5%AF%BC%E8%87%B4%E6%97%A0%E6%B3%95%E9%80%89%E4%B8%AD%E6%96%87%E5%AD%97%2F</url>
    <content type="text"><![CDATA[安装 网页便利贴 后发现一些输入框内的文字无法选中，左键松开选中就消失了。]]></content>
      <tags>
        <tag>chrome</tag>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu桌面卡住解决办法]]></title>
    <url>%2F2020%2F07%2F15%2Fubuntu%E6%A1%8C%E9%9D%A2%E5%8D%A1%E4%BD%8F%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[alt + ctrl + f1登录(login)sudo lightdm restart 测试中，原来打开的窗口都还在。]]></content>
      <tags>
        <tag>方法</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于unity的git版本控制]]></title>
    <url>%2F2020%2F06%2F28%2F%E5%85%B3%E4%BA%8Eunity%E7%9A%84git%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[unity版本控制，只需对Assets和ProjectSettings做git控制就可以了并且，不用担心，只包含这两个文件夹的工程也可以被unity hub添加为项目的，它会自己补上其他的。]]></content>
      <tags>
        <tag>unity</tag>
        <tag>方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python编码及decode、encode]]></title>
    <url>%2F2020%2F06%2F12%2Fpython%E7%BC%96%E7%A0%81%E5%8F%8Adecode%E3%80%81encode%2F</url>
    <content type="text"><![CDATA[什么是编码计算机是01二进制的，我们看到的文字等数据和二进制的转换规则就是编码。编码历史漂亮国发明计算机后，用8位01组合(2^8=256)做出了第一个转换规则，就是所谓的ASCII表。计算机进入中国256个字符不够用，还要表示汉字呢，于是对ASCII进行了扩展，就是GB2312。后续又不够用，扩展为GB18030。同理每个国家都有自己的编码。必须安装这种编码才能看懂对应意思。 后来国际上起草了一个统一编码能表示任何国家的文字，就是UNICODE。使用的是两个字节2^16=65536表示所有文字，好像并不多啊。 然后漂亮国觉得自己吃亏了，本来一个字节就可以表示的，浪费一倍存储空间。于是提出了一种新的格式，较通用转换格式UTF,这个U就是UNICODE，常见的有utf-8，utf-16，说白了就是一种变长编码方法，信息论里常见的很，于是美国一个字节，欧洲两个字节，东南亚三个字节，感觉我们吃亏了一个字节。 decode和encodepython内部是unicode，以unicode作为中间编码，其他编码需要先解码成unicode，再从unicode编码成另一种编码。python里的字符串是unicode编码的，可以看作是python在内存中的原始编码，转化为其他的如GB2312、utf-8需要编码，是编码，即python的unicode到其他编码方式间都是编码，编码。反过来才是解码。以下编码都是可以的：123456789101112&gt;&gt;&gt; aa&#x3D;&quot;abc&quot;;type(aa)&lt;class &#39;str&#39;&gt;&gt;&gt;&gt; bb&#x3D;aa.encode(&quot;utf-8&quot;);type(bb)&lt;class &#39;bytes&#39;&gt;&gt;&gt;&gt; cc&#x3D;aa.encode(&quot;utf-16&quot;);type(cc)&lt;class &#39;bytes&#39;&gt;&gt;&gt;&gt; dd&#x3D;aa.encode(&quot;GB2312&quot;);type(dd)&lt;class &#39;bytes&#39;&gt;&gt;&gt;&gt; ee&#x3D;aa.encode(&quot;GB18030&quot;);type(ee)&lt;class &#39;bytes&#39;&gt;&gt;&gt;&gt; ff&#x3D;ee.decode(&quot;GB18030&quot;);type(ff)&lt;class &#39;str&#39;&gt;从上面代码可以看到不是unicode就是不str，只要是unicode编码的就是str，其他编码都是bytesunicode可以看作底层的统一的，它到其他都是编码。 关系图]]></content>
      <tags>
        <tag>总结</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git嵌套]]></title>
    <url>%2F2020%2F06%2F10%2Fgit%E5%B5%8C%E5%A5%97%2F</url>
    <content type="text"><![CDATA[git嵌套的好处1.可以多个人同时完成一个项目，每人完成项目不同的部分2.可以将一段代码独立出来多出复用，同时可以对这一个功能单独进行维护（如hexo的主题）git嵌套方法1.简单易理解，不推荐的直接在对应的位置git clone缺点是在其他位置clone的时候要查找各个git的地址分别git2.submodule，推荐方法：先单独创建各个仓库，push到github等，然后通过git submodule add添加到指定位置（ 这种方法不会引起什么混乱，子模块都是通过submodule添加的。缺点是创建了太多独立文件夹。）另一种方法是把整个结构在初始好，如各自加上readme文件，由低级到上级逐个git push,最后删除子仓库通过git submodule add添加。 如果子模块不多，第一种方法还好些。并且很多项目里使用的子模块并不多，比如有git仓库里只用了一个。注意：主仓库内的子仓库是有对应版本的，在github可以清楚看到，所以子仓库更新后父仓库也是要commit的，如果此时不commit反而pull会把子仓库更新的版本覆盖掉的。多数情况下多人合作还是各自更新，然后merge的，较少考虑使用子仓库，如果做的内容比较独立，我想子仓库是更好更清晰的选择。有多个相同子模块也是也各自更新的，在github里可以看到，同一个模块，在一个仓库里存在的版本并不同 在子仓库拉去的方法：1git pull origin HEAD:master 因为他的状态常常不是最前端，需要指定位置才行。其他地方的拉去也尽量采用git pull origin,以规范操作方式。]]></content>
      <tags>
        <tag>方法</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测速工具iperf3编译安装]]></title>
    <url>%2F2020%2F06%2F09%2F%E6%B5%8B%E9%80%9F%E5%B7%A5%E5%85%B7iperf3%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[下载1wget -c https:&#x2F;&#x2F;iperf.fr&#x2F;download&#x2F;source&#x2F;iperf-3.1.3-source.tar.gz解压编译123456tar -zxvf iperf-3.1.3-source.tar.gzcd iperf-3.1.3&#x2F;.&#x2F;configuremakesudo sumake install 修复一个小问题12iperf3ldconfig 运行1234567# 服务端iperf3 -s# 客户端iperf3 -c 127.0.0.1 -t 10# 或iperf3 -c 192.168.1.114 -t 10 根据测试本地还是测试多机通信决定]]></content>
      <tags>
        <tag>方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux查看系统版本相关信息]]></title>
    <url>%2F2020%2F06%2F09%2Flinux%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E7%89%88%E6%9C%AC%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF%2F</url>
    <content type="text"><![CDATA[仅内核版本1uname -a 内核版本、gcc版本12345cat &#x2F;proc&#x2F;version&#96;&#96;&#96; 命令很简单，可以记住### 查看系统版本代号 lsb_release -a```也很简单要记住]]></content>
      <tags>
        <tag>方法</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu下升级git]]></title>
    <url>%2F2020%2F06%2F09%2Fubuntu%E4%B8%8B%E5%8D%87%E7%BA%A7git%2F</url>
    <content type="text"><![CDATA[123sudo add-apt-repository ppa:git-core&#x2F;ppasudo apt updatesudo apt install git]]></content>
      <tags>
        <tag>方法</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对熵的简单理解]]></title>
    <url>%2F2020%2F06%2F08%2F%E5%AF%B9%E7%86%B5%E7%9A%84%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[简言之，事情越不确定熵越大假设有5枚硬币，都是正面，只有一种方式，3个正面2个反面，很多排列方式他们的熵分别为12S1 &#x3D; -1*ln(1)&#x3D;0S2 &#x3D; -1*(0.4*ln0.4+0.6*ln0.6)*5&#x3D;3.365 熵越大含的信息量越多比如神经网络分类的结果，假设有5类，一种是1，0，0，0，0，另一种是0.21，0.36,…类似上面的计算就可以得出第二种熵更大，它喊得信息也更多，可以用作知识蒸馏中的soft label，学生网络能学到更多信息。 越混乱熵越高，越稳定熵越低]]></content>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[unity的inspector面板值不随脚本改变的理解]]></title>
    <url>%2F2020%2F06%2F01%2Funity%E7%9A%84inspector%E9%9D%A2%E6%9D%BF%E5%80%BC%E4%B8%8D%E9%9A%8F%E8%84%9A%E6%9C%AC%E6%94%B9%E5%8F%98%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[unity脚本声明的一些public变量，一旦挂到游戏体上以后，在脚本修改这些值的时候，inspector面板里并不修改。你可以这么理解它的机制：你写一个脚本后你可以把它挂在多个游戏体上，你可以为每个脚本拉上当前所在的游戏体，你也可以对每个游戏体进行编号，这些都是可以直接在inspector界面拉到脚本上或写到脚本上的。unity为了实现让你随便拉游戏体的功能，在inspector面板上暴露出来的变量都是和这个游戏体绑定的，不是原来的脚本简单复制。 所以：不需要单独赋值的变量一律使用private，需要被其他脚本引用的变量，为它创建一个方法，直接返回该变量。即：除非单独一个脚本在多出使用，且分别赋值给变量，否则一律使用声明为私有变量。]]></content>
      <tags>
        <tag>unity</tag>
        <tag>方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux下自写定时器注意事项]]></title>
    <url>%2F2020%2F05%2F29%2Flinux%E4%B8%8B%E8%87%AA%E5%86%99%E5%AE%9A%E6%97%B6%E5%99%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[linux下可以方便的自写定时器脚本。常用的是每60秒判断一下时间。以每5分钟git pull一次为例。需要计算分钟数对5的余数为0.但是可能会出现一个03%5的情况，这时候脚本计算会出错。可以通过对分钟值加10来避免。简单的脚本如下：1234567891011121314while truedo thetime&#x3D;$(date &quot;+%M&quot;) thetime2&#x3D;&#96;expr $thetime + 10&#96; remainder&#x3D;$(($thetime2%5)) if [ $remainder &#x3D; &#39;0&#39; ] then cd ~&#x2F;blog;sh gitpull.sh date sleep 60s else sleep 60s fidoneshell脚本中以0开头的数字如08，和其他数字相加的时候往往会出现问题，需要先自己在终端下实验成功。上面使用expr的方式是可行的。 需要注意的是，如果脚本语法有不严谨的地方，计算出错会导致整个脚本终止掉，这就是有时莫名停止的原因]]></content>
      <tags>
        <tag>方法</tag>
        <tag>linux</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[unity安卓分辨率适配]]></title>
    <url>%2F2020%2F05%2F28%2Funity%E5%AE%89%E5%8D%93%E5%88%86%E8%BE%A8%E7%8E%87%E9%80%82%E9%85%8D%2F</url>
    <content type="text"><![CDATA[这里以u2d为例：在开发的时候选一个16/9的分辨率，比如667/375。在画布中设置好分辨率375/667。在Game窗口可以选择多种分辨率比例进行测试。有些分辨率是2:1的，这时候在不改变画布大小的情况下，将背景图片拉伸或放一张更长的图片就可以实现对2:1分辨率的简单适配。比如可以将处于底层的背景图片的宽/高修改为375/867，这样就可以实现对页面的简单适配，解决屏幕上下部分出现空白的问题。 当然还可以更好的适配，比如先获取设备的分辨率，然后按比例确定上下端元素的位置，比如一些位移和释放技能的位置。代码：123# 在默认using UnityEngine;的情况下Screen.heightScreen.width]]></content>
      <tags>
        <tag>unity</tag>
        <tag>方法</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim在全文替换字符串]]></title>
    <url>%2F2020%2F05%2F24%2Fvim%E5%9C%A8%E5%85%A8%E6%96%87%E6%9B%BF%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[1:1,$s&#x2F;abc&#x2F;efg&#x2F;g表示从第一行开始将所有的abc替换为efg当前行替换1:s&#x2F;abc&#x2F;efg&#x2F;g当前行只替换第一个1:s&#x2F;abc&#x2F;efg&#x2F; 回顾一下vim查找关键字1&#x2F;abc 即为查找，按n继续查找。]]></content>
      <tags>
        <tag>方法</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[unity无法调整游戏体位置的可能原因]]></title>
    <url>%2F2020%2F05%2F21%2Funity%E6%97%A0%E6%B3%95%E8%B0%83%E6%95%B4%E6%B8%B8%E6%88%8F%E4%BD%93%E4%BD%8D%E7%BD%AE%E7%9A%84%E5%8F%AF%E8%83%BD%E5%8E%9F%E5%9B%A0%2F</url>
    <content type="text"><![CDATA[在测试粒子系统的时候遇到无法调整游戏体位置的情况，即使将位置的数值更改了，游戏体还在原来的位置。 排查后发现是因为把其父游戏体的规模缩小为0了，位置是修改了但是在Scene窗口是看不出来变化的。]]></content>
      <tags>
        <tag>unity</tag>
        <tag>方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[unity粒子特效]]></title>
    <url>%2F2020%2F05%2F21%2Funity%E7%B2%92%E5%AD%90%E7%89%B9%E6%95%88%2F</url>
    <content type="text"><![CDATA[控制方向默认是发散的，把Rect Transform里的Rotation为（90，0，0），方向就是朝下。控制喷射粒子的长度逐渐调整粒子系统主面版的Start Lifetime数值，可以看到火焰长度的变化 控制粒子体积变化激活Size over Lifetime，点击面板上方打开编辑器，即可调整体积百分比随时间变化 调整粒子的频率或者说间隔激活Emission，调整单位时间生成粒子的数量RateOverTime即可]]></content>
      <tags>
        <tag>unity</tag>
        <tag>方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[unity图片大小变化后整体偏移的原来位置的方法]]></title>
    <url>%2F2020%2F05%2F20%2Funity%E5%9B%BE%E7%89%87%E5%A4%A7%E5%B0%8F%E5%8F%98%E5%8C%96%E5%90%8E%E6%95%B4%E4%BD%93%E5%81%8F%E7%A7%BB%E7%9A%84%E5%8E%9F%E6%9D%A5%E4%BD%8D%E7%BD%AE%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[感觉上是锚点相关的内容。实际上可以通过子游戏体轻松实现。在子游戏体里微调位置，同时父游戏体还是原来的逻辑，不用修改脚本里的对应内容。]]></content>
      <tags>
        <tag>unity</tag>
        <tag>方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu18.04部署hexo]]></title>
    <url>%2F2020%2F05%2F20%2Fubuntu18-04%E9%83%A8%E7%BD%B2hexo%2F</url>
    <content type="text"><![CDATA[ubuntu安装node参考连接：https://github.com/nodesource/distributions/blob/master/README.md指令：1234567# Using Ubuntucurl -sL https:&#x2F;&#x2F;deb.nodesource.com&#x2F;setup_12.x | sudo -E bash -sudo apt-get install -y nodejs# Using Debian, as rootcurl -sL https:&#x2F;&#x2F;deb.nodesource.com&#x2F;setup_12.x | bash -apt-get install -y nodejs 查看版本12node -vnpm -v 安装hexo1npm install -g hexo-cli 查看hexo自带功能1hexo 可能会没有server参数 新建文章12hexo n alitsetvim source&#x2F;_posts&#x2F;alitest.md 逐步部署查找问题123hexo cleanhexo generatehexo deploy 处理ERROR Deployer not found: git 错误1npm install --save hexo-deployer-git 配置git邮箱和用户名信息12git config --global user.email 1xxxx@qq.comgit config --global user.name wxxx 尝试部署1sd deploy.sh 查看hexo功能此时可能出现server参数了1hexo 启动服务到默认端口或指定端口123hexo server或hexo server -p 80 更多hexo信息参考：https://hexo.io/zh-cn/docs/server.html 后台运行1setsid hexo server -p 80]]></content>
      <tags>
        <tag>方法</tag>
        <tag>hexo</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[unity的PlayerPrefs的初始化方法]]></title>
    <url>%2F2020%2F05%2F14%2Funity%E7%9A%84PlayerPrefs%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[以整形为例，不管是GetInt()还是SetInt(),其中的默认参数并不是如果没有这个key值将这个数值赋给它，而是返回这个数值作为替代。 网上有的文章说的，用它们的第二个参数来初始化是不对的。但是有一个方法可以初始化：先查找有没有这个key值，没有则给它赋值，有则不再赋值，这样可以达到初始化的效果。代码如下：1234&#x2F;&#x2F; 初始化if(!PlayerPrefs.HasKey(energy))&#123; PlayerPrefs.SetInt(&quot;energy&quot;, 30)&#125;]]></content>
      <tags>
        <tag>unity</tag>
        <tag>方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[unity发布webgl和android不能返回值、调用函数的原因]]></title>
    <url>%2F2020%2F05%2F14%2Funity%E5%8F%91%E5%B8%83webgl%E5%92%8Candroid%E4%B8%8D%E8%83%BD%E8%BF%94%E5%9B%9E%E5%80%BC%E3%80%81%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%E7%9A%84%E5%8E%9F%E5%9B%A0%2F</url>
    <content type="text"><![CDATA[所有的这些原因，无法进入游戏、无法打开成功/失败结束页面等主要是因为调用和litjson相关的函数了。使用这种需要引入dll的方法，一定要注意查清楚在各个平台的打包问题。所以要左多平台发布，尤其是有webgl，尽量使用unity自带的工具实现。 老博客地址：https://www.jianshu.com/u/1c73a3a8ae2d新博客地址：https://inspiring26.github.io/]]></content>
      <tags>
        <tag>unity</tag>
        <tag>方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[unity2D分辨率适配]]></title>
    <url>%2F2020%2F05%2F14%2Funity2D%E5%88%86%E8%BE%A8%E7%8E%87%E9%80%82%E9%85%8D%2F</url>
    <content type="text"><![CDATA[假如你以375667的分辨率做的游戏，现在要适配1080\1920分辨率的机器（这个分辨率是目前比较主流的分辨率）。不用一个个元素的修改，也有一个前提，如果想图不糊，你是把1080*1920的图放在了375*667的框里，这样放大才不糊。 具体扩大分辨率的方法是：在Canvas的Canvas Scaler 里将mode选择Scale with Screen，第二行的默认分辨率写成你实际开发过程中的分辨率，本例中是375*667。然后去game窗口将比例调成16:9(9:16)或其他分辨率，就可以看到真实的显示效果。 老博客地址：https://www.jianshu.com/u/1c73a3a8ae2d新博客地址：https://inspiring26.github.io/]]></content>
      <tags>
        <tag>unity</tag>
        <tag>方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[unity脚本修改数据无效问题]]></title>
    <url>%2F2020%2F05%2F12%2Funity%E8%84%9A%E6%9C%AC%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE%E6%97%A0%E6%95%88%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[unity中修改脚本数据后经常会发现运行时并没有使用修改后的数据，尤其是数组数据等。这时需要在脚本对应的inspector里点击齿轮，选择reset，此后就会使用脚本里的数据。需要经常对比二者数据是否一致，所以较好的方法是将数据初始化在Start()函数里。例如：12345public int[] arrSong &#x3D; new int[115];Start()&#123; arrSong &#x3D; new int[115]&#123;,,,,&#125;;&#125; 老博客地址：https://www.jianshu.com/u/1c73a3a8ae2d新博客地址：https://inspiring26.github.io/]]></content>
      <tags>
        <tag>unity</tag>
        <tag>方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多出编辑更新hexo博客方法]]></title>
    <url>%2F2020%2F05%2F06%2F%E5%A4%9A%E5%87%BA%E7%BC%96%E8%BE%91%E6%9B%B4%E6%96%B0hexo%E5%8D%9A%E5%AE%A2%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[首先在原博客处建立分支，将hexo后端文件同步到github如source分支hexo建立的blog，一开始是没有git init的，这一点记不清了也没验证。要把源文件更新到github的话，先git init，然后建立、切换分支，提交，添加远程git仓库地址，推送本地到远程。代码如下：1234567git initgit checkout -b sourcegit add -Agit commit -m &quot;init blog&quot;git remote add origin git@github.com:&#123;username&#125;&#x2F;&#123;username&#125;.github.io.gitgit push origin source在这以后是可以切换master和source分支的。 在树莓派上配置环境安装node使用二进制代码安装比较好，也不需要编译.先去node.js官方网站下载：https://nodejs.org/zh-cn/download/代码如下：123456wget -c https:&#x2F;&#x2F;nodejs.org&#x2F;dist&#x2F;v12.16.3&#x2F;node-v12.16.3-linux-armv7l.tar.xzsudo mkdir -p &#x2F;usr&#x2F;local&#x2F;lib&#x2F;nodejssudo tar -xJvf node-v12.16.3-linux-armv7l.tar.xz -C &#x2F;usr&#x2F;local&#x2F;lib&#x2F;nodejscd ~sudo echo &quot;export PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;nodejs&#x2F;node-v12.16.3-linux-armv7l&#x2F;bin:$PATH&quot; &gt;&gt; .bashrcsource .bashrc然后，用hexo -v ;npm -v 验证版本。 安装hexo以管理员权限安装hexo1sudo npm install -g hexo-cli git clone 远程仓库1234git clone git@XXX# 切换到新分支# 这里需要新建并切换git checkout -b source origin&#x2F;source 切换到blog文件夹运行hexo运行hexo，这时回报错，根据提示再次安装12npm install hexo --savenpm audit fix 去专门的仓库拉去主题（这一步也可以改成将主题下的.git文件删除，一次拉去源文件和主题的）1234cd themerm -r nextgit clone git@XXXcd .. 验证创建新文章12hexo n &quot;测试文章&quot;vim source&#x2F;_posts&#x2F;测试文章.md 将两处连接添加到文章末尾（希望在文末追加一些固定文字时才需要此步骤）1cat links.txt &gt;&gt; source&#x2F;_posts&#x2F;多出编辑更新hexo博客方法.md 验证本地运行1hexo s 验证远程推送到github page1sh deploy.sh 验证成功后可以推送源文件的更新到github的source分支1git push 老博客地址：https://www.jianshu.com/u/1c73a3a8ae2d新博客地址：https://inspiring26.github.io/]]></content>
      <tags>
        <tag>方法</tag>
        <tag>hexo</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派上编辑更新测试]]></title>
    <url>%2F2020%2F05%2F06%2F%E6%A0%91%E8%8E%93%E6%B4%BE%E4%B8%8A%E7%BC%96%E8%BE%91%E6%9B%B4%E6%96%B0%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[这是在树莓派上]]></content>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多处编辑测试]]></title>
    <url>%2F2020%2F05%2F06%2F%E5%A4%9A%E5%A4%84%E7%BC%96%E8%BE%91%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[测试]]></content>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客多处更新，多处git控制的经验]]></title>
    <url>%2F2020%2F04%2F28%2Fhexo%E5%8D%9A%E5%AE%A2%E5%A4%9A%E5%A4%84%E6%9B%B4%E6%96%B0%EF%BC%8C%E5%A4%9A%E5%A4%84git%E6%8E%A7%E5%88%B6%E7%9A%84%E7%BB%8F%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[【注意】本文内容不完善，新的步骤参考 多出编辑更新hexo博客方法背景在ubuntu主机上有一个hexo的完整环境，可以发布更新博客。目标在ubuntu、MBA、树莓派等设备上都可以进行博客更新，并且数据一致（本文章是在MBA上完成） 步骤第一,推送到gitgub在ubuntu上hexo根目录，12345git checkout -b source #创建新分支sourcegit add -Agit commit -m &quot;init blog&quot;git remote add origin git@github.com:&#123;username&#125;&#x2F;&#123;username&#125;.github.io.gitgit push origin source #本地origin推到source单独推送主题文件夹：123456cd theme&#x2F;next&#x2F;git initgit add -Agit commit -m &quot;first commit&quot;git remote add origin git@github.com:&#123;username&#125;&#x2F;&#123;username&#125;.theme.next.git #这个仓库是新建的，专门用来存放改动过的主题nextgit push -u origin master 第二，安装node环境MBA：12brew install node.jsnpm install -g hexo-cli其他端类似，就是安装node和hexo 第三，pullMBA:12345678git clone git@github.com:&#123;username&#125;&#x2F;&#123;username&#125;.github.io.gitgit checkout sourcegit pull #这两部是切换分支，和拉去改分支文件，其实就是个切换，文件提前一起拉下来了cd themegit clone git@github.com:&#123;username&#125;&#x2F;&#123;username&#125;.theme.next.gitmv theme.next nextcd ..hexo s到次应该可以正常运行了 总结要git clone某个分支：123git clone git@github.com:&#123;username&#125;&#x2F;&#123;username&#125;.github.io.gitgit checkout sourcegit pull仓库中有仓库，也就是说.git文件夹的子文件夹还要.git时，在处理上层.git时，会忽略下层的，只保留了个文件夹名]]></content>
      <tags>
        <tag>方法</tag>
        <tag>hexo</tag>
        <tag>git</tag>
        <tag>同步</tag>
        <tag>多终端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[unity开发的一些感想]]></title>
    <url>%2F2020%2F04%2F23%2Funity%E5%BC%80%E5%8F%91%E7%9A%84%E4%B8%80%E4%BA%9B%E6%84%9F%E6%83%B3%2F</url>
    <content type="text"><![CDATA[可以新建一个游戏体上面存储所有要操作的数据，如果游戏场景比较多，可以在接近根结点的每个大游戏体上简历几个脚本，分别存储不同的信息。信息集中管理逻辑更清晰，在其他脚本中的引用也更少。少了错综复杂的引用，当然更清晰，更易于管理。集中管理的好处还是很多的。可以集中的有，数据、帧操作等。 在实现一个逻辑时可以注释列出要做的各个步骤，这样非常易于逻辑的展开1234&#x2F;&#x2F; 判断可点击区域内是否miss&#x2F;&#x2F; 这个区域可以比正常的状态判定区域稍微大一些，给点晚了的miss一些时间段&#x2F;&#x2F; 第一步，判断是否在可点按区域。方法是起点一个数组，终点一个数组，如果进入了第一个没进入第二个就是在区域内&#x2F;&#x2F; 第二步，判断是否点击。方法是起点进入时给一个未点击标识，到达终点时检查一下是否点了 12345678public void CloseHearts(int n)&#123;&#x2F;&#x2F;传入丢失星星数 &#x2F;&#x2F; 第一步，将所有heart按顺序装入数组 &#x2F;&#x2F; 第二步，从最后一个开始倒序关闭 for(int i&#x3D;2;i&gt;2-n;i--)&#123; heartList[i].transform.localScale &#x3D; new Vector3(0f,0f,1f); &#125;&#125; 游戏体的Find、实例化都放在Start()里，这个不用多说尽量一数组的方式进行操作，将问题转为数组，转化为纯粹的数学问题，条理更清晰，运行效率也更高。老博客地址：https://www.jianshu.com/u/1c73a3a8ae2d新博客地址：https://inspiring26.github.io/]]></content>
      <tags>
        <tag>unity</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The type or namespace name 'Text' could not be found]]></title>
    <url>%2F2020%2F04%2F22%2FThe-type-or-namespace-name-Text-could-not-be-found%2F</url>
    <content type="text"><![CDATA[这个问题的原因很可能是没有声明对应的namespaces，在unity中使用UI构建物体，修改或调用其自带的脚本如Text等是需要先1using UnityEngine.UI;]]></content>
      <tags>
        <tag>unity</tag>
        <tag>方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[unity的webgl文件夹部署到Apache的详细步骤]]></title>
    <url>%2F2020%2F04%2F17%2Funity%E7%9A%84webgl%E6%96%87%E4%BB%B6%E5%A4%B9%E9%83%A8%E7%BD%B2%E5%88%B0Apache%E7%9A%84%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4%2F</url>
    <content type="text"><![CDATA[在网上找了半天就没有一个把unity发布为webgl，并部署到Apache的详细方法。所以自己写一个发布为webgl在unity窗口file-&gt;build setting-&gt;选中webgl；至少选中一个场景；webgl右侧什么都不选；然后build and run； 编译结束会在本地浏览器打开网页，要保证这一步哪呢个通说明游戏没问题。 部署到Apache安装apache以ubuntu下为例：123456789101112131415161718192021222324apache2 -version &#x2F;&#x2F;验证有没有sudo apt updatesudo apt install apache2apache2 -version &#x2F;&#x2F;验证是否安装成功&#x2F;&#x2F;配置UFW防火墙sudo ufw app list&#x2F;&#x2F;包含以下信息ApacheApache FullApache SecureCUPSOpenSSHsudo ufw allow &#39;Apache&#39;&#x2F;&#x2F;验证Apache服务是否正在运行。&#x2F;&#x2F;其实我在这一项有些功能没有正常运行，但是并没影响后面webgl的运行sudo systemctl status apache2&#x2F;&#x2F;可以查看本地ip 方便复制使用hostname -I在浏览器里打开，可以看到apache的默认页面；找到www/html信息的位置；以管理员权限修改index.html文件名；以管理员权限将webgl的Build、TemplateData、index.html文件复制到/var/www/html/下1sudo cp -r .&#x2F;* &#x2F;var&#x2F;www&#x2F;html&#x2F; 打开localhost]]></content>
      <tags>
        <tag>unity</tag>
        <tag>方法</tag>
        <tag>Apache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[unity/c#数组装变量的两种方法]]></title>
    <url>%2F2020%2F04%2F17%2Funity-c-%E6%95%B0%E7%BB%84%E8%A3%85%E5%8F%98%E9%87%8F%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一开始想详细写，后因全栈开发较忙，搁置了一段时间，现简单描述一下方法一使用打印功能擦看出对应的类型AudioClip、Rigidbody2D等直接用他们申明数组，多维的用下面之类的格式1public Rigidbody2D[,] R2D &#x3D; new Rigidbody2D[10,27]; 注意不能对太底层的申明，因为那就是深拷贝了，无法达到引用的目的深浅拷贝可以看这里 方法二使用object声明，之后再对数组进行转型，如下1newlsit &#x3D; (AudioClip[])someList;]]></content>
      <tags>
        <tag>unity</tag>
        <tag>方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[unity2D朝向目标的方法]]></title>
    <url>%2F2020%2F04%2F17%2Funity2D%E6%9C%9D%E5%90%91%E7%9B%AE%E6%A0%87%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[以火箭始终朝向砖块为例123Vector3 dir &#x3D; brickList[target%10].transform.position - rocket.transform.position;float angle &#x3D; Mathf.Atan2(dir.y,dir.x) * Mathf.Rad2Deg;rocket.transform.rotation &#x3D; Quaternion.AngleAxis(270+angle, Vector3.forward); Mathf.Atan2反正弦函数，输入两个参数：y轴长度、x轴长度如Mathf.Atan2(1,1)的值为0.7853982，约是3.14除以4。 Mathf.Rad2Deg弧度到度的转化常量，等于360/（PI*2）还有一个相反的函数Mathf.Deg2Rad Quaternion.AngleAxisQuaternion是unity中的四元数，123456&#x2F;&#x2F;transform沿y轴旋转30度 transform.rotation &#x3D; Quaternion.AngleAxis(30, Vector3.up); &#x2F;&#x2F;transform沿z轴旋转30度 transform.rotation &#x3D; Quaternion.AngleAxis(30, Vector3.forward); &#x2F;&#x2F;transform沿x轴旋转30度 transform.rotation &#x3D; Quaternion.AngleAxis(30, Vector3.left);]]></content>
      <tags>
        <tag>unity</tag>
        <tag>方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[unity加载图片、音乐及替换到指定组件上的总结]]></title>
    <url>%2F2020%2F04%2F15%2Funity%E5%8A%A0%E8%BD%BD%E5%9B%BE%E7%89%87%E3%80%81%E9%9F%B3%E4%B9%90%E5%8F%8A%E6%9B%BF%E6%8D%A2%E5%88%B0%E6%8C%87%E5%AE%9A%E7%BB%84%E4%BB%B6%E4%B8%8A%E7%9A%84%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[音乐读取我这里是通过c#的object和unity的GameObject分别读取，然后贴在GameObject的组件的clip上，之后可以直接对组件调用Play()、Pause()、Stop()方法，和对loop之类的参数赋值。代码：123456789101112131415private string[] songList &#x3D; &#123;&quot;fade_cut&quot;,&quot;Flirting_With_June_cut&quot;,&quot;lzttdmg_cut&quot;,&quot;Ocean_cut&quot;,&quot;Relax_cut&quot;&#125;;private object objs;private GameObject GObject;public void LoadMusic(int num)&#123; objs &#x3D; Resources.Load(songList[num]); GObject.GetComponent&lt;AudioSource&gt;().clip &#x3D; (AudioClip)objs; GObject.GetComponent&lt;AudioSource&gt;().Play(); GObject.GetComponent&lt;AudioSource&gt;().loop &#x3D; true;&#125;void Start()&#123; GObject &#x3D; GameObject.Find(&quot;SelectionPage&quot;);&#125;可以提前加载的尽量方Start()里加载，示例中也可以提前加载成数组，但是考虑到内存资源的的占用使用的逐个加载。以上使用了c#自带方法，提供了一种理解角度，更符合unity语法的方法如下： 读取（unity风格）(主流方法）代码：1234567891011121314private string[] songList &#x3D; &#123;&quot;fade_cut&quot;,&quot;Flirting_With_June_cut&quot;,&quot;lzttdmg_cut&quot;,&quot;Ocean_cut&quot;,&quot;Relax_cut&quot;&#125;; private AudioClip objs; private GameObject GObject; public void LoadMusic(int num)&#123; objs &#x3D; Resources.Load(songList[num], typeof(AudioClip)) as AudioClip; GObject.GetComponent&lt;AudioSource&gt;().clip &#x3D; objs; GObject.GetComponent&lt;AudioSource&gt;().Play(); GObject.GetComponent&lt;AudioSource&gt;().loop &#x3D; true; &#125; void Start()&#123; GObject &#x3D; GameObject.Find(&quot;SelectionPage&quot;); &#125;使用1Resources.Load(路径, typeof(目标格式)) as 目标格式;形式读取。 更简洁的写法1234567891011121314151617181920private string[] songList &#x3D; &#123;&quot;fade_cut&quot;,&quot;Flirting_With_June_cut&quot;,&quot;lzttdmg_cut&quot;,&quot;Ocean_cut&quot;,&quot;Relax_cut&quot;&#125;; private AudioClip objs; private GameObject GObject; private AudioSource audioSource; public void LoadMusic(int num)&#123; objs &#x3D; Resources.Load(songList[num], typeof(AudioClip)) as AudioClip; audioSource.clip &#x3D; objs; audioSource.Play(); audioSource.loop &#x3D; true; &#125; void Start() &#123; GObject &#x3D; GameObject.Find(&quot;SelectionPage&quot;); Debug.Log(GObject.GetComponent&lt;AudioSource&gt;()); &#x2F;&#x2F; 查看要用变量指代的具体是什么类型 audioSource &#x3D; GObject.GetComponent&lt;AudioSource&gt;(); LoadMusic(0); &#x2F;&#x2F; 打开游戏就播放 &#125; 可以更进一步用变量替代重复的调用语句，如1GObject.GetComponent&lt;AudioSource&gt;()具体声明为什么格式，可以先打印看一下。另外开场就进行的操作，如播放音乐，可以放在Start()里。 注意需要注意的是要播放音乐，必须先把音乐组件放在某个游戏体上，不能凭空播放音乐。 图片读取读取系统自带的图像组件，必须使用1using UnityEngine.UI;否则会找不到Image。 代码：12345678910111213141516171819private Image icon;public Sprite sp1,sp2;public void ChangeThePicture()&#123; if(this.GetComponent&lt;Scrollbar&gt;().value &lt; 0.5)&#123; icon.sprite &#x3D; sp1; &#125;else&#123; icon.sprite &#x3D; sp2; &#125; &#125; &#x2F;&#x2F; Start is called before the first frame update void Start() &#123; icon &#x3D; this.GetComponent&lt;Image&gt;(); sp1 &#x3D; Resources.Load(&quot;Pictures&#x2F;SettingPage&#x2F;矩形 3943 拷贝&quot;, typeof(Sprite)) as Sprite; sp2 &#x3D; Resources.Load(&quot;Pictures&#x2F;SettingPage&#x2F;bg_kaiguan&quot;, typeof(Sprite)) as Sprite; &#125; 总结图片挂的是sprite，音乐挂的是clip，都不是检视窗口内左侧的对应名字。出于节省资源的考虑，可以把sp1、sp2这种多次使用的图片在父物体里以public方式加载，在当前脚本里调用即可，不在当前脚本加载是为了保持脚本重复利用。于是另一个结论，重复利用的脚本不加载资源。]]></content>
      <tags>
        <tag>unity</tag>
        <tag>方法</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[unity脚本里的this和获取Scrollbar里的滑动值]]></title>
    <url>%2F2020%2F04%2F15%2Funity%E8%84%9A%E6%9C%AC%E9%87%8C%E7%9A%84this%E5%92%8C%E8%8E%B7%E5%8F%96Scrollbar%E9%87%8C%E7%9A%84%E6%BB%91%E5%8A%A8%E5%80%BC%2F</url>
    <content type="text"><![CDATA[在脚本里使用this替代GameObject.Find(“”)，可以让一个脚本在多个相似功能的游戏体上使用，this指挂载的那个游戏体。通过1this.GetComponent&lt;Scrollbar&gt;().value 就可以获得Scrollbar的滑动值。]]></content>
      <tags>
        <tag>unity</tag>
        <tag>方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[unity命名、文件夹注意事项]]></title>
    <url>%2F2020%2F04%2F15%2Funity%E5%91%BD%E5%90%8D%E3%80%81%E6%96%87%E4%BB%B6%E5%A4%B9%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[unity的游戏体一定要好好命名，不要重名不重名是因为后续基本都是用GameObject.Find(“”)查找游戏体。查找的时候务必加上多级路径提升查找效率；多次使用要提前查找、赋值给变量；所有查找放在Start()里。 命名除了列表内容不使用数字，用能表达出意思的英文。 Assets至少应该包括Resources、Scenes、Scripts、Pictures文件夹Resources存放音视频，应分为多个文件夹，文件夹以主要游戏体命名，如2D开发中画布下的游戏体。除非有特殊的需求，一般不用过于细分。Scenes存放游戏场景，业务量不大的话建议使用一个主场景，一个测试功能的场景。Scripts存放游戏脚本，分为多个文件夹，文件夹以主要游戏体命名。Pictures存放游戏图片，分为多个文件夹，文件夹以主要游戏体命名。]]></content>
      <tags>
        <tag>unity</tag>
        <tag>注意事项</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[unity引用游戏体的两种方式]]></title>
    <url>%2F2020%2F04%2F14%2Funity%E5%BC%95%E7%94%A8%E6%B8%B8%E6%88%8F%E4%BD%93%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[第一种是在脚本的类里方法外public声明，挂载后拉上去，好处是可以处理未激活的游戏体，一次声明多次使用。第二种是使用1GameObject.Find(&quot;Bricks1&quot;)只要名字不重复，随时可以使用，但是每次使用都要Find效率略低，不能Find未激活的游戏体。并且要注意游戏体是否被其他程序设置为未激活了，比如你前一步程序把它的父物体设置未激活了就会导致找不到实体。 GameObject.Find() 有很多缺陷，不能引用各种未激活的游戏体，比如开始游戏要激活某个游戏体就不能用它。只要是经历过未激活状态的就不能再用它激活。不想大量提前声明，使用GameObject.Find()而又不导致无法引用错误的方法是，将2D、3D物体的scale分别变为（0，0，1）和（0，0，0）。]]></content>
      <tags>
        <tag>unity</tag>
        <tag>方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[unity的GameObject]]></title>
    <url>%2F2020%2F04%2F13%2Funity%E7%9A%84GameObject%2F</url>
    <content type="text"><![CDATA[1GameObject.Find(&quot;Bricks1&quot;).GetComponent&lt;MakeBricksMove&gt;().enabled&#x3D;true; 可以调用很多游戏体，但是不能调用没激活的游戏体。要调用没预先没激活的游戏体，需要用public声明引用。]]></content>
      <tags>
        <tag>unity</tag>
        <tag>方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[unity的Image透明度]]></title>
    <url>%2F2020%2F04%2F13%2Funity%E7%9A%84Image%E9%80%8F%E6%98%8E%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[unity UI的Image，如果设置为透明只需在颜色里调整A值就可以了。A值代表的是不透明度，越大越不透明。但是当值为0和1或255和254时是很不同的，代表了一种开关。要使背景全透，就要设置为1，不能设置为0。除此外，可以加上不同的颜色形成不同颜色的遮罩。]]></content>
      <tags>
        <tag>unity</tag>
        <tag>方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[unity设置游戏暂停透明背景]]></title>
    <url>%2F2020%2F04%2F13%2Funity%E8%AE%BE%E7%BD%AE%E6%B8%B8%E6%88%8F%E6%9A%82%E5%81%9C%E9%80%8F%E6%98%8E%E8%83%8C%E6%99%AF%2F</url>
    <content type="text"><![CDATA[添加一个全屏Image将颜色修改为黑色，如090919将A值调到200，代表不透明程度这样就建立了一个继续显示游戏内容的暂停界面]]></content>
      <tags>
        <tag>unity</tag>
        <tag>方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[unity创建滑动拉近的选关界面]]></title>
    <url>%2F2020%2F04%2F08%2Funity%E5%88%9B%E5%BB%BA%E6%BB%91%E5%8A%A8%E6%8B%89%E8%BF%91%E7%9A%84%E9%80%89%E5%85%B3%E7%95%8C%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[通过修改要显示的关卡图片的大小和位置，就能实现一种类似初代iphone滑动选择专辑的界面。]]></content>
      <tags>
        <tag>unity</tag>
        <tag>方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[unity创建滚动条]]></title>
    <url>%2F2020%2F04%2F08%2Funity%E5%88%9B%E5%BB%BA%E6%BB%9A%E5%8A%A8%E6%9D%A1%2F</url>
    <content type="text"><![CDATA[在遮挡图片同级创建一个scrollbar，调整他的位置及滑动方向，一般选第三个bottom to top，然后在遮蔽图片的scroll rect组件中有一个vertical Scrollbar区域来添加竖向滑动。 结构：— 背景图片— — 遮蔽图片— — — 要显示的内容— — Scrollbar]]></content>
      <tags>
        <tag>unity</tag>
        <tag>方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[unity切换场景的方法]]></title>
    <url>%2F2020%2F04%2F03%2Funity%E5%88%87%E6%8D%A2%E5%9C%BA%E6%99%AF%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[目前了解到的切换场景、页面的方法是创建多个场景进行跳转创建两个空场景n1、n2同时加载n1、n2，在file-&gt;build setting里添加两个场景，使编号分别为0、1，关闭设置窗口。单独打开n1，让n2不加载或者移除n2 在层级窗口，创建UI-&gt;Button 在项目窗口创建c sharp文件，命名为Jump，如下图编辑此文件。 将Jump拉到Canvas的检视窗口，为什么要拉到这里，是因为下一步添加脚本不能直接拉C sharp文件，需要拉一个游戏体。这一步可以理解为安置，下一步理解为引用。 选中Button游戏体，在检视窗口的button脚本下按加号，将Canvas游戏体拉到runtime only下，在runtime only右选择Jump.OnLoginButtonClick 加载n2，卸载n1，创建Image，拉一张图片到检视窗口的下图位置，图片要先处理为精灵，调整长宽。 保存场景，加载n1，卸载n2，paly，成功。]]></content>
      <tags>
        <tag>unity</tag>
        <tag>方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[unity播放视频，方法二]]></title>
    <url>%2F2020%2F04%2F03%2Funity%E6%92%AD%E6%94%BE%E8%A7%86%E9%A2%91%EF%BC%8C%E6%96%B9%E6%B3%95%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[首先在画布游戏体里创建一个rawImage。解释一下：为什么要在画布游戏体里创建？因为画可以理解成一个容器，其他ui元素都填充到该容器中。如果你直接创建rawImage，系统会自动创建一个canvas，并把rawImage放在canvas下。当然你也可以先船舰canvas，再选中它创建rawImage，效果是一样的。 另外，你加到canvas的组件并不会直接显示，而是在rawImage中设置的窗口里显示。你把video palyer挂到canvas或rawImage上都可以，但显示窗口由rawImage决定。 「只有放在画布下的子物体才参与ui的渲染。」 在画布中将宽、高调整为500、500，在Raw Image（script）里将新建的材质拉进去。 材质随意新建一个就可以。 将Video player组件添加到canvas或rawImage，感觉添加到后者更合理，将视频和材质都拉到对应的位置，渲染模式设置为rander texture。 播放即可看到效果，视频、声音都有。]]></content>
      <tags>
        <tag>unity</tag>
        <tag>方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu下往unity添加视频文件的方法]]></title>
    <url>%2F2020%2F04%2F03%2Fubuntu%E4%B8%8B%E5%BE%80unity%E6%B7%BB%E5%8A%A0%E8%A7%86%E9%A2%91%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[直接添加mp4等文件失败的原因是unity需要使用quicktime player作为视频的播放器。mac自带，windows可以安装，linux不好处理。 解决方法用ffmpeg将视频转换成unity自身支持的ogv格式。指令：1ffmpeg -i video.mp4 vode.ogv再次导入即可成功。]]></content>
      <tags>
        <tag>unity</tag>
        <tag>方法</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[unity播放视频]]></title>
    <url>%2F2020%2F04%2F03%2Funity%E6%92%AD%E6%94%BE%E8%A7%86%E9%A2%91%2F</url>
    <content type="text"><![CDATA[1.在层级窗口创建空白游戏体2.游戏体的检视窗口添加video player组件3.video player 组件里源选择“video clip”，视频拉如下面的位置，渲染模式选择“camera far plane”，把层级窗口的主摄像机拉到下面位置。 4.播放，即可看到加入的视频]]></content>
      <tags>
        <tag>unity</tag>
        <tag>方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[golang安装gin失败解决办法]]></title>
    <url>%2F2020%2F03%2F20%2Fgolang%E5%AE%89%E8%A3%85gin%E5%A4%B1%E8%B4%A5%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1.开启代理服务器1export GO111MODULE&#x3D;on]]></content>
      <tags>
        <tag>方法</tag>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo文章注意事项]]></title>
    <url>%2F2020%2F03%2F20%2Fhexo%E6%96%87%E7%AB%A0%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[tags: 和其后的方括号间要有空格任何使用方括号花括号或者变量的地方，尽量用三点括起来，不然会报错。在hexo中引用号不能写在一行，引用号后不能有空格，因为它要表现为mac终端的形式。在简书中倒是可以写成一行。 老博客地址：https://www.jianshu.com/u/1c73a3a8ae2d新博客地址：https://inspiring26.github.io/]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>注意事项</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell编程注意事项]]></title>
    <url>%2F2020%2F03%2F20%2Fshell%E7%BC%96%E7%A8%8B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[定义变量时，变量名不加美元符号；变量名和等号间不能有空格；除了自己赋值，还可以用语句，如：for file in `ls /etc`;使用变量需加美元符，有两种：1$file $&#123;file&#125; 后者方便和其他字符串拼接；变量可以被重新定义或者说赋值，依然不加美元号； 以#开头的行是注释，被忽略；shell里没有多行注释符；对于代码块，可以用花括号括起来定义成函数，不调用时达到注释代码块效果； 只有两种数据类型，数字、字符串；字符串可以单引号、双引号、不引号,单引号内不能有变量、单引号的转义，双引号可以有变量、双引号的转义； 字符串拼接，1$file直接在空间上拼接，1$&#123;file&#125;可以在双引号内拼接； 获取字符串长度：1$&#123;#file&#125; 提取子字符串：1$&#123;#file:1:4&#125;下标从0开始计算，就是第1个到第4个，不是第1个到第三个； linux里的[是可执行程序，位置在1&#x2F;usr&#x2F;bin&#x2F;[所以前后必须有空格； if else:写成一行，有值的都算True1if ps -ef | grep ssh;then echo hello;fi写成脚本1234if ps -ef | grep sshthen echo hellofi其他情况：12345678910111213141516if ps -ef | grep sshthen echo helloelse echo world #else后是不能为空的fiif ps -ef | grep sshthen echo helloelif ps -ef | grep auto echo world #else后是不能为空的else echo greatfi for while:1234for var in item1 item2 ... itemndo commanddone写成一行：1for var in item1 item2 ... itemN; do command1; command2… ;done#命令间要用分号分开，done在最后一个命令之后单起一句，其后加不加分号都可以也可以传统for风格1234567for (( var&#x3D;1;var&lt;5 ;var++))do echo $vardone#单行for (( var&#x3D;1;var&lt;5;var++));do echo $var;done while:1234while conditiondo commanddone无限循环：1234567891011121314151617while :do commanddone或者while truedo commanddone或者for (( ; ;))do commanddone 一个类似与while的until1234util conditiondo commanddone 还有一直case语法了解一下123456789101112131415161718192021222324252627case &quot;$&#123;opt&#125;&quot; in &quot;Install-Puppet-Server&quot; ) install_master $1 exit ;; &quot;Install-Puppet-Client&quot; ) install_client $1 exit ;; &quot;Config-Puppet-Server&quot; ) config_puppet_master exit ;; &quot;Config-Puppet-Client&quot; ) config_puppet_client exit ;; &quot;Exit&quot; ) exit ;; * ) echo &quot;Bad option, please choose again&quot;esac 在bash里source和.是等效的，他们都是读入并执行指定文件12source .&#x2F;function.sh. .&#x2F;function.sh 顺便提一下获取文件绝对路径的方法12&gt;&gt;&gt;readlink -f test.sh&#x2F;home&#x2F;h2&#x2F;test.sh有这样的综合使用分析：readlink -f test.sh 是一个可执行shell语句，效果是获取test.sh的绝对路径要把执行完语句的结果传给变量的话，需要用``将语句括起来，123456789&gt;&gt;&gt;testpath&#x3D;\&#96;readlink -f test.sh\&#96;此时$testpath 的值就是路径字符串，直接运行$testpath 是运行该文件，可能会有权限问题，&gt;&gt;&gt;. $testpath &gt;&gt;&gt;source $testpath 都是执行那个脚本&gt;&gt;&gt;echo $testpath 是打印出路径地址 老博客地址：https://www.jianshu.com/u/1c73a3a8ae2d新博客地址：https://inspiring26.github.io/]]></content>
      <tags>
        <tag>注意事项</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决终端远程连接服务器，无法运行hexo的问题]]></title>
    <url>%2F2020%2F03%2F19%2F%E8%A7%A3%E5%86%B3%E7%BB%88%E7%AB%AF%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E6%97%A0%E6%B3%95%E8%BF%90%E8%A1%8Chexo%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[source ～/.bashrc执行后终端会变色，可以使用常用指令了。不能root后再执行，因为root后～/代表的位置已经不同了。 老博客地址：https://www.jianshu.com/u/1c73a3a8ae2d新博客地址：https://inspiring26.github.io/]]></content>
      <tags>
        <tag>方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[删除Mac一直显示的提示信息]]></title>
    <url>%2F2020%2F03%2F18%2F%E5%88%A0%E9%99%A4Mac%E4%B8%80%E7%9B%B4%E6%98%BE%E7%A4%BA%E7%9A%84%E6%8F%90%E7%A4%BA%E4%BF%A1%E6%81%AF%2F</url>
    <content type="text"><![CDATA[先找到产生功能提示框的应用，如微信、终端。移动应用位置，通过新窗口或其他任何方式，让类似气泡再产生一次，类似气泡即可。 老博客地址：https://www.jianshu.com/u/1c73a3a8ae2d新博客地址：https://inspiring26.github.io/]]></content>
      <tags>
        <tag>方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python将大文件夹拆分成小文件夹]]></title>
    <url>%2F2020%2F03%2F17%2Fpython%E5%B0%86%E5%A4%A7%E6%96%87%E4%BB%B6%E5%A4%B9%E6%8B%86%E5%88%86%E6%88%90%E5%B0%8F%E6%96%87%E4%BB%B6%E5%A4%B9%2F</url>
    <content type="text"><![CDATA[123456import osos.system(&quot;mkdir pic_move1;mkdir pic_move2&quot;)plist &#x3D; next(os.walk(&quot;pic_move&quot;))[2]print(len(plist))for i in range(5000): os.system(&quot;mv .&#x2F;pic_move&#x2F;&quot;+plist[i]+&quot; .&#x2F;pic_move1&#x2F;&quot;) 依次类推完成转移]]></content>
      <tags>
        <tag>方法</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将nvidia添加到runtime]]></title>
    <url>%2F2020%2F03%2F16%2F%E5%B0%86nvidia%E6%B7%BB%E5%8A%A0%E5%88%B0runtime%2F</url>
    <content type="text"><![CDATA[要使docker容器能调用本地的gpu,有三种种方法。一是，安装nvidia-docker，该方法已被官方舍弃，地址为https://github.com/NVIDIA/nvidia-docker#upgrading-with-nvidia-docker2-deprecated二是，安装nvidia-container-toolkit，后添加—gpus参数来使用，地址为:安装https://github.com/NVIDIA/nvidia-docker#ubuntu-16041804-debian-jessiestretchbuster使用https://github.com/NVIDIA/nvidia-docker#usage三是，安装nvidia-container-runtime，在首次运行时添加—runtime=nvidia参数，后续启动、结束都不需要再加。安装使用流程为：1234567891011121314apt-get install nvidia-container-runtimetee &#x2F;etc&#x2F;docker&#x2F;daemon.json &lt;&lt;EOF&#123; &quot;runtimes&quot;: &#123; &quot;nvidia&quot;: &#123; &quot;path&quot;: &quot;&#x2F;usr&#x2F;bin&#x2F;nvidia-container-runtime&quot;, &quot;runtimeArgs&quot;: [] &#125; &#125;&#125;EOFdocker run --runtime&#x3D;nvidia --rm nvidia&#x2F;cuda nvidia-smi #正常就可以了]]></content>
      <tags>
        <tag>方法</tag>
        <tag>docker</tag>
        <tag>nvidia</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.16开始回公司上班]]></title>
    <url>%2F2020%2F03%2F16%2F3-16%E5%BC%80%E5%A7%8B%E5%9B%9E%E5%85%AC%E5%8F%B8%E4%B8%8A%E7%8F%AD%2F</url>
    <content type="text"><![CDATA[回公司上班的第一天。一路坐车过来，等到公司摘下口罩，两边脸上已经是很深的印子了。。。]]></content>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[各个搜索引擎对我的GithubPages博客的收录情况]]></title>
    <url>%2F2019%2F12%2F30%2F%E5%90%84%E4%B8%AA%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E5%AF%B9%E6%88%91%E7%9A%84GithubPages%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%94%B6%E5%BD%95%E6%83%85%E5%86%B5%2F</url>
    <content type="text"><![CDATA[以下站点只有百度和google做过提交或推送。感觉在简书文章下加上新博客地址是有用的。百度：63个链接google：96个链接bing：16个链接360：1个链接。没有推送过，收录原因可能是从简书获取的。搜狗：一个没有。用sites去搜索更是一堆无关的结果。duckduckgo：基本可以获取所以站内文章。 老博客地址：https://www.jianshu.com/u/1c73a3a8ae2d新博客地址：https://inspiring26.github.io/]]></content>
      <tags>
        <tag>GitHub Pages</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apple Watch 的两个隐藏功能]]></title>
    <url>%2F2019%2F12%2F27%2FApple-Watch-%E7%9A%84%E4%B8%A4%E4%B8%AA%E9%9A%90%E8%97%8F%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[1.在点亮屏幕后，双指放在时间上，手表会报时。 2.手表戴到手上需要解锁，如果此时手机解锁一次，手表就会自动解锁。 老博客地址：https://www.jianshu.com/u/1c73a3a8ae2d新博客地址：https://inspiring26.github.io/]]></content>
      <tags>
        <tag>Apple Watch</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图片色彩叠加]]></title>
    <url>%2F2019%2F12%2F27%2F%E5%9B%BE%E7%89%87%E8%89%B2%E5%BD%A9%E5%8F%A0%E5%8A%A0%2F</url>
    <content type="text"><![CDATA[当我们想在一个彩色图片上用一种颜色标识出相关信息，同时不覆盖原有信息，一个简单的方式是直接取各自RGB通道的数值，按一定百分比相加即可。123456789101112131415from PIL import Imagefrom skimage import ioimport numpy as npimport matplotlib.pyplot as pltimage1 &#x3D; Image.open(&quot;aa.jpg&quot;)image2 &#x3D; Image.open(&quot;bb.jpg&quot;)image1 &#x3D; np.array(image1)image2 &#x3D; np.array(image2)image2[...,0] &#x3D; image1[...,0]*0.4 + iamge2[...,0]*0.6image2[...,1] &#x3D; image1[...,1]*0.4 + iamge2[...,1]*0.6image2[...,2] &#x3D; image1[...,2]*0.4 + iamge2[...,2]*0.6io.imshow(image2);plt.show()当要标注时 选择指定的范围替换即可。 老博客地址：https://www.jianshu.com/u/1c73a3a8ae2d新博客地址：https://inspiring26.github.io/]]></content>
      <tags>
        <tag>方法</tag>
        <tag>图像</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[appstore切换帐号带来的影响总结]]></title>
    <url>%2F2019%2F12%2F02%2Fappstore%E5%88%87%E6%8D%A2%E5%B8%90%E5%8F%B7%E5%B8%A6%E6%9D%A5%E7%9A%84%E5%BD%B1%E5%93%8D%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[apple musicapple music下载的音乐会全部被删除airpodsairpods需要重新通过icloud连接，并且要长按背后按钮apple watchapple watch里下载的音乐需要重新下载 老博客地址：https://www.jianshu.com/u/1c73a3a8ae2d新博客地址：https://inspiring26.github.io/]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python简单而有用的日常脚本操作]]></title>
    <url>%2F2019%2F11%2F27%2Fpython%E7%AE%80%E5%8D%95%E8%80%8C%E6%9C%89%E7%94%A8%E7%9A%84%E6%97%A5%E5%B8%B8%E8%84%9A%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[获取文件夹内所有文件名12import osnext(os.walk(&#39;.&#39;))[2]移动文件等shell操作12import osos.system(&quot;mv aa bb&quot;) 多线程实际使用中可以通过htop看到，执行一个处理时只会把一个cpu线程核心用满，想充分利用cpu和节省时间，就要多用多线程。用起来非常简单，建议传入参数，以便分段同时执行123import threadingt1 &#x3D; threading.Thread(target&#x3D;handle, args&#x3D;(1,len(namelist)&#x2F;&#x2F;2),name&#x3D;&#39;1&#39;)t1.run()举个用例1234567891011&gt;&gt;&gt; def handle(s,d):... for i in range(s,d):... im &#x3D; Image.open(namelist[i])... (width, height) &#x3D; (im.width&#x2F;max(im.width,im.height)*2000,im.height&#x2F;max(im.width,im.height)*2000)... im_re &#x3D; im.resize(( int(width), int(height) ))... im_re.save(&quot;..&#x2F;hands3&#x2F;&quot;+namelist[i])... &gt;&gt;&gt; t1 &#x3D; threading.Thread(target&#x3D;handle, args&#x3D;(1,len(namelist)&#x2F;&#x2F;2),name&#x3D;&#39;1&#39;)&gt;&gt;&gt; t1.start()&gt;&gt;&gt; t2 &#x3D; threading.Thread(target&#x3D;handle, args&#x3D;(len(namelist)&#x2F;&#x2F;2,len(namelist)),name&#x3D;&#39;2&#39;)&gt;&gt;&gt; t2.start() 老博客地址：https://www.jianshu.com/u/1c73a3a8ae2d新博客地址：https://inspiring26.github.io/]]></content>
      <tags>
        <tag>技巧</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python的sys.path模块]]></title>
    <url>%2F2019%2F11%2F21%2Fpython%E7%9A%84sys-path%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[见到这种用法1sys.path.append(ROOT_DIR)查看文档后知道python只有sys.path方法，它是一个列表，里面记录的是python搜索模块的路径。原话是A list of strings that specifies the search path for modules.一个字符串列表，列表指定了模块的搜索路径。再具体一点，其初始化的时候是从PYTHONPATH中获取的地址字符串。 你读文档，还要是英文文档，你才能了解并用上各种最新的模块。 老博客地址：https://www.jianshu.com/u/1c73a3a8ae2d新博客地址：https://inspiring26.github.io/]]></content>
      <tags>
        <tag>python</tag>
        <tag>英文文档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mask rcnn里优秀的python用法]]></title>
    <url>%2F2019%2F11%2F21%2Fmask-rcnn%E9%87%8C%E4%BC%98%E7%A7%80%E7%9A%84python%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[获取绝对路径1os.path.abspath(&quot;..&#x2F;&quot;)联合路径或文件12os.path.join(ROOT_DIR, &quot;samples&#x2F;coco&#x2F;&quot;)os.path.join(ROOT_DIR, &quot;mask_rcnn_coco.h5&quot;) 如果不存在就下载或创建12if not os.path.exists(COCO_MODEL_PATH): utils.download_trained_weights(COCO_MODEL_PATH) 组织参数及调用 以及传参，用一部分也可以传整个，显得很简洁1234567891011class InferenceConfig(coco.CocoConfig): # Set batch size to 1 since we&#39;ll be running inference on # one image at a time. Batch size &#x3D; GPU_COUNT * IMAGES_PER_GPU GPU_COUNT &#x3D; 1 IMAGES_PER_GPU &#x3D; 1config &#x3D; InferenceConfig()config.GPU_COUNT()model &#x3D; modellib.MaskRCNN(mode&#x3D;&quot;inference&quot;, model_dir&#x3D;MODEL_DIR, config&#x3D;config) 列出文件夹里的所有文件和文件夹1next(os.walk(IMAGE_DIR))[2] 随机选取一个元素1random.choice(file_names) 老博客地址：https://www.jianshu.com/u/1c73a3a8ae2d新博客地址：https://inspiring26.github.io/]]></content>
      <tags>
        <tag>技巧</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell脚本if基础的整数、字符串比较]]></title>
    <url>%2F2019%2F11%2F21%2Fshell%E8%84%9A%E6%9C%ACif%E5%9F%BA%E7%A1%80%E7%9A%84%E6%95%B4%E6%95%B0%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[整数比较等于1&quot;$a&quot; -eq &quot;$b&quot; ] #不加引号也可以的不等于1if [ &quot;$a&quot; -ne &quot;$b&quot; ]大于1if [ &quot;$a&quot; -gt &quot;$b&quot; ] 字符串比较等于12if [ &quot;$a&quot; &#x3D; &quot;$b&quot; ]if [ &quot;$a&quot; &#x3D;&#x3D; &quot;$b&quot; ]#两种都可以，应该要加引号的，没测试不等于1if [ &quot;$a&quot;x !&#x3D; &quot;$b&quot;x ]还可以用通配符的12345if [[ &quot;123&quot; &#x3D; &quot;12&quot;* ]];then echo &quot;&#x3D;&quot;;fi&#x3D;if [[ &quot;123&quot; &#x3D; 12* ]];then echo &quot;&#x3D;&quot;;fi&#x3D;#通配符匹配的时候尽量用双括号，具体使用时自己先验证以下 老博客地址：https://www.jianshu.com/u/1c73a3a8ae2d新博客地址：https://inspiring26.github.io/]]></content>
      <tags>
        <tag>方法</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网站状态码302和200]]></title>
    <url>%2F2019%2F11%2F21%2F%E7%BD%91%E7%AB%99%E7%8A%B6%E6%80%81%E7%A0%81302%E5%92%8C200%2F</url>
    <content type="text"><![CDATA[可以通过以下shell命令来获取网站的状态码1curl -o &#x2F;dev&#x2F;null -s -w &quot;%&#123;http_code&#125;&quot; &quot;http:&#x2F;&#x2F;192.168.1.111:5006&#x2F;login&#x2F;&quot;返回结果是200 如果访问的链接是1curl -o &#x2F;dev&#x2F;null -s -w &quot;%&#123;http_code&#125;&quot; &quot;http:&#x2F;&#x2F;192.168.1.111:5006&quot;返回的结果是302，表示链接进行了跳转. 可以通过以下方式获取访问网站状态码：12HTTP_CODE&#x3D;&#96;curl -o &#x2F;dev&#x2F;null -s -w &quot;%&#123;http_code&#125;&quot; &quot;http:&#x2F;&#x2F;192.168.1.111:5006&#x2F;login&#x2F;&quot;&#96;$HTTP_CODE 老博客地址：https://www.jianshu.com/u/1c73a3a8ae2d新博客地址：https://inspiring26.github.io/]]></content>
      <tags>
        <tag>方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网站没被收录，使用百度抓取诊断工具测试]]></title>
    <url>%2F2019%2F11%2F19%2F%E7%BD%91%E7%AB%99%E6%B2%A1%E8%A2%AB%E6%94%B6%E5%BD%95%EF%BC%8C%E4%BD%BF%E7%94%A8%E7%99%BE%E5%BA%A6%E6%8A%93%E5%8F%96%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[以我的网站为例，打开连接https://ziyuan.baidu.com/crawltools/index?site=http://inspiring26.github.io/在空格处补全输入其中一篇文章的地址：12019&#x2F;11&#x2F;05&#x2F;使用python建立两台电脑之间的连接抓取后的结果：点击抓取失败，查看详情： 说明我们即使主动推送网站内链接，百度依然抓取不到的。这个并不怪百度。github禁止百度蜘蛛爬取了。 老博客地址：https://www.jianshu.com/u/1c73a3a8ae2d新博客地址：https://inspiring26.github.io/]]></content>
      <tags>
        <tag>方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[注意，pandas的loc、iloc后面是方括号]]></title>
    <url>%2F2019%2F11%2F19%2F%E6%B3%A8%E6%84%8F%EF%BC%8Cpandas%E7%9A%84loc%E3%80%81iloc%E5%90%8E%E9%9D%A2%E6%98%AF%E6%96%B9%E6%8B%AC%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[df = …loc和iloc是直接读取行的区别在iloc参数是数字，loc参数是字符串读取列的话，有三种，分别是. [] 上面两种的应用df.0df[0]df.loc[:,[]] df.iloc[:,[]] #内部的方括号中不能用切片，可以列举。外部的可以用切片 老博客地址：https://www.jianshu.com/u/1c73a3a8ae2d新博客地址：https://inspiring26.github.io/]]></content>
      <tags>
        <tag>pandas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[homepod睡觉定时关闭音乐]]></title>
    <url>%2F2019%2F11%2F15%2Fhomepod%E7%9D%A1%E8%A7%89%E5%AE%9A%E6%97%B6%E5%85%B3%E9%97%AD%E9%9F%B3%E4%B9%90%2F</url>
    <content type="text"><![CDATA[两步。1，让homepod播放指定音乐列表或指定风格音乐2，让homepod在指定时间后停止播放待测试让homepod在指定时间开始播放音乐，用作起床闹钟。1You’re permitted to ask Siri to set up a sleep timer for anywhere from a couple of seconds to 23 hours and 59 minutes. What you cannot do is ask the assistant to set a sleep timer for a precise time, like 11pm. And lastly, you obviously cannot make multiple sleep timers.是不能精确定时的，那就测测若干时间后停止播放。 新博客地址：https://inspiring26.github.io/]]></content>
      <tags>
        <tag>方法</tag>
        <tag>homepod</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读源码torch.nn.Module]]></title>
    <url>%2F2019%2F11%2F15%2F%E8%AF%BB%E6%BA%90%E7%A0%81torch-nn-Module%2F</url>
    <content type="text"><![CDATA[def init(self):定义了很多有序字典OrderedDict()在创建网络时，我们要实现该方法，通过spuer方法将init里的表达式继承下来。从python类的用法上讲，也可以采用baseClass.__init__()的方式，但是通常不这么用，这里每验证这么用会不会出问题，只是温习一下python的使用方法。 def forward(self, *input):这个方法要被重写，上面的init方法叫实现。该方法传入输入。12def forward(self, *input): raise NotImplementedError采用这种方式达到不重写就会报对应的错。方法很好。 def register_buffer(self, name, tensor):向模块添加持久缓冲区。12345678910111213141516171819def register_buffer(self, name, tensor): if &#39;_buffers&#39; not in self.__dict__: raise AttributeError( &quot;cannot assign buffer before Module.__init__() call&quot;) elif not isinstance(name, torch._six.string_classes): raise TypeError(&quot;buffer name should be a string. &quot; &quot;Got &#123;&#125;&quot;.format(torch.typename(name))) elif &#39;.&#39; in name: raise KeyError(&quot;buffer name can&#39;t contain \&quot;.\&quot;&quot;) elif name &#x3D;&#x3D; &#39;&#39;: raise KeyError(&quot;buffer name can&#39;t be empty string \&quot;\&quot;&quot;) elif hasattr(self, name) and name not in self._buffers: raise KeyError(&quot;attribute &#39;&#123;&#125;&#39; already exists&quot;.format(name)) elif tensor is not None and not isinstance(tensor, torch.Tensor): raise TypeError(&quot;cannot assign &#39;&#123;&#125;&#39; object to buffer &#39;&#123;&#125;&#39; &quot; &quot;(torch Tensor or None required)&quot; .format(torch.typename(tensor), name)) else: self._buffers[name] &#x3D; tensor如果参数name类型不对会报相应的错。 def register_parameter(self, name, param):向模块添加参数。同样会做一些格式和存在与否的判断，进而报错，这是我应该学习的方式。两个参数分了三步去判断。 def add_module(self, name, module):给当前模块添加一个子模块。同时做一些isinstance hasattr == 的判断raise一些TypeError KeyError def _apply(self, fn):这是后续方法要经常调用的方法pytorch的更新参数最底层的方法都是这个方法和def apply(self, fn)定义的。 def apply(self, fn):def cuda(self, device=None):将所有模型参数和缓冲区移至GPU。12def cuda(self, device&#x3D;None): return self._apply(lambda t: t.cuda(device)) def cpu(self):将所有模型参数和缓冲区移至CPU。12def cpu(self): return self._apply(lambda t: t.cpu()) def type(self, dst_type):将所有参数和缓冲区强制转换为dst_type。12def type(self, dst_type): return self._apply(lambda t: t.type(dst_type)) def float(self):将所有浮点参数和缓冲区强制转换为float数据类型。12def float(self): return self._apply(lambda t: t.float() if t.is_floating_point() else t) def double(self):将所有浮点参数和缓冲区强制转换为“ double”数据类型。 def half(self):将所有浮点参数和缓冲区强制转换为“ half”数据类型。Half是用16位表示浮点数的一种数据类型，在IEEE 754中也有规定，这种数据类型在深度学习系统中的应用比较广泛。但是在当前主流cpu上，不支持half类型数据的计算和输出，所以需要half和float两个数据类型之间的转换。IEEE754-2008包含一种“半精度”格式，只有16位宽。故它又被称之为binary16，这种类型的浮点数只适合用于存储那些对精度要求不高的数字，不适合用于进行计算。与单精度浮点数相比，它的优点是只需要一半的存储空间和带宽，但是缺点是精度较低。 def to(self, *args, **kwargs):移动或强制转换参数和缓冲区。1234567891011121314151617181920212223242526Example:: &gt;&gt;&gt; linear &#x3D; nn.Linear(2, 2) &gt;&gt;&gt; linear.weight Parameter containing: tensor([[ 0.1913, -0.3420], [-0.5113, -0.2325]]) &gt;&gt;&gt; linear.to(torch.double) Linear(in_features&#x3D;2, out_features&#x3D;2, bias&#x3D;True) &gt;&gt;&gt; linear.weight Parameter containing: tensor([[ 0.1913, -0.3420], [-0.5113, -0.2325]], dtype&#x3D;torch.float64) &gt;&gt;&gt; gpu1 &#x3D; torch.device(&quot;cuda:1&quot;) &gt;&gt;&gt; linear.to(gpu1, dtype&#x3D;torch.half, non_blocking&#x3D;True) Linear(in_features&#x3D;2, out_features&#x3D;2, bias&#x3D;True) &gt;&gt;&gt; linear.weight Parameter containing: tensor([[ 0.1914, -0.3420], [-0.5112, -0.2324]], dtype&#x3D;torch.float16, device&#x3D;&#39;cuda:1&#39;) &gt;&gt;&gt; cpu &#x3D; torch.device(&quot;cpu&quot;) &gt;&gt;&gt; linear.to(cpu) Linear(in_features&#x3D;2, out_features&#x3D;2, bias&#x3D;True) &gt;&gt;&gt; linear.weight Parameter containing: tensor([[ 0.1914, -0.3420], [-0.5112, -0.2324]], dtype&#x3D;torch.float16) def register_backward_hook(self, hook):在模块上注册反向挂钩。每当计算相对于模块输入的梯度时，都会调用该挂钩。 def register_forward_pre_hook(self, hook):在模块上注册前向预钩。每次调用：func：forward之前，都会调用该钩子。 def register_forward_hook(self, hook):在模块上注册一个前向挂钩。每当：func：forward计算出输出后，该钩子就会被调用。 def _slow_forward(self, *input, **kwargs):没有加速的前向函数. def _call_(self, *input, **kwargs):给个参数就执行的前向调用? def _setstate_(self, state):快速设置所有字典状态 def _getattr_(self, name):获取属性 def _setattr_(self, name, value):设置属性 def _delattr_(self, name):删除属性 def _register_state_dict_hook(self, hook):这个钩子可以就地修改“ state_dict”或返回一个新的。 def_save_to_state_dict(self, destination, prefix, keep_vars):将模块状态保存到“destination”字典中，其中包含模块的状态，但不包含其后代。 def state_dict(self, destination=None, prefix=’’, keep_vars=False):返回包含模块整个状态的字典。 def _register_load_state_dict_pre_hook(self, hook):这些钩子将被以下参数进行调用：state_dict，prefix，local_metadata，strict，strict，missing_keys，unexpected_keys， error_msgs，在将state_dict加载到self之前。 这些参数与_load_from_state_dict的参数完全相同。 def _load_from_state_dict(self, state_dict, prefix, local_metadata, strict, missing_keys, unexpected_keys, error_msgs):从:attr:’state_dict’复制参数和缓冲区。 def load_state_dict(self, state_dict, strict=True):将参数和缓冲区从state_dict复制到此模块及其后代中。 def _named_members(self, get_members_fn, prefix=’’, recurse=True):产生各种名称+模块成员的辅助方法。 def parameters(self, recurse=True):返回模块参数上的迭代器。 def named_parameters(self, prefix=’’, recurse=True):返回包含模块参数的迭代器，yield返回参数名称和参数本身。 def buffers(self, recurse=True):返回模块缓冲的迭代器。 def named_buffers(self, prefix=’’, recurse=True):返回模块缓冲的迭代器，包括缓冲的名字和缓冲本身。 def children(self):返回直接子模块构成的迭代器。123def children(self): for name, module in self.named_children(): yield module def named_children(self):返回直接子模块的迭代器，同时yield返回模块的名称和模块本身。 def modules(self):返回网络中所有模块的迭代器。 def named_modules(self, memo=None, prefix=’’):同时返回名字 def train(self, mode=True):常用的，如model.train()作用是使模块处于训练状态。mode=True training modemode=True evaluation mode代码很简单12345def train(self, mode&#x3D;True): self.training &#x3D; mode #使self.training&#x3D;True for module in self.children(): 把children以及children的children也设置为True，所以这里使用的是调用自己，进而构成循环 module.train(mode) return selfreturn self是一种链式调用。1234567891011121314class Foo(object): def __init__(self): self.myattr &#x3D; 0 def bar(self): self.myattr +&#x3D; 1 return selff &#x3D; Foo()f.bar().bar().bar()print(f.myattr)输出结果为3.把bar()方法改为返回return None， 则上述代码会出错。 def eval(self):12def eval(self): return self.train(False) def requiresgrad(self, requires_grad=True):这个也是很重要很常用的函数Change if autograd should record operationson parameters in this module.控制自动求导是否记录求导结果，它是单个模块控制的。12345def requires_grad_(self, requires_grad&#x3D;True): for p in self.parameters(): p.requires_grad_(requires_grad) #也是递归的调用，也是return self return self def zero_grad(self):将所有模型参数的梯度设置为零。123456def zero_grad(self): r&quot;&quot;&quot;Sets gradients of all model parameters to zero.&quot;&quot;&quot; for p in self.parameters():#遍历所以参数 if p.grad is not None:#如果存在 p.grad.detach_() p.grad.zero_()#使用其他函数设置为0此外，123def parameters(self, recurse&#x3D;True): for name, param in self.named_parameters(recurse&#x3D;recurse): yield param所以self.parameters()是parameters方法产生的一个递归。最终用到的数据来自module._parameters.items() def share_memory(self):好像是共享内存 def _get_name(self):12def _get_name(self): return self.__class__.__name__ 返回本类的名字 def extra_repr(self):设置模块的额外表示形式12def extra_repr(self): return &#39;&#39;默认为空字符串，需要重写该方法以达到额外命名 def repr(self):一个表示形式，用到上面的额外命名，分有没有额外名情况去组织结果。 def dir(self):老博客地址：https://www.jianshu.com/u/1c73a3a8ae2d新博客地址：https://inspiring26.github.io/]]></content>
      <tags>
        <tag>读源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对现在监督学习、非监督学习、bert等模型的思考]]></title>
    <url>%2F2019%2F11%2F14%2F%E5%AF%B9%E7%8E%B0%E5%9C%A8%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E3%80%81%E9%9D%9E%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E3%80%81bert%E7%AD%89%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[不管是bert类的大规模预训练模型，还是视觉领域最新的把ImageNet准确率提升1%的Noisy Student，他们一个共同的特点，非监督学习。非监督学习的好处是数据大，通过大规模数据更容易学到其中的隐含规律、一般规律。bert用了一种很巧妙的方法，开了个好头，一个新的思维方向。数据量很多没法标注对把，我们可以把模型的结果设置称一种简单的关系，我们的目标是通过大量隐藏层去学到一个语言的内在关系。bert采用的方法：1，是使用两句话是否为上下句这种关系作为标签。这种关系不需要人工标注，通过简单的算法记录一下哪些是被分割开的就能实现。2，还有一种方法是遮蔽部分词，让模型去预测，这种方法同样不需要标注数据，因为标签就是你遮蔽掉的词。3，不仅仅做一种预测训练，既做了只有两个类别的上下句预测，又做了预测单词的非分类。我感觉这样使模型输出的结果不同，尽量减少对单一特定任务的效果，而是通过切换最后一层功能，尽量使模型学到的只是语言的特点，具体来说会在较深的层次中对各种词语搭配、句子骨干比较敏感，做出相应的反馈。举个例子：词语块：123解放碑吃火锅农民辛苦 水稻...骨干类：123xxx 是 xxx 榜样xxx 省 xxx 市... 再说说Noisy Student，它是以监督训练开始的，后续循环使用上一个老师预测的结果作为标签，可以看作是扩大规模的监督学习，因为后续不需要人工打标签，整体上可以看作是非监督学习。在过程中加入了噪声数据，可以理解为是扩大数据类型，让模型学到对细节块的识别、敏感度。后期在正确的预测上一跑，之前对细节块的敏感性、识别能力可以用的到。当它能很好的识别细节后，一个funetuning之类的操作就很得到很好的结果。 总结想办法提升模型对细节块的识别能力是提升准确率的一个方向。 老博客地址：https://www.jianshu.com/u/1c73a3a8ae2d新博客地址：https://inspiring26.github.io/]]></content>
      <tags>
        <tag>深度学习</tag>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu升级cmake]]></title>
    <url>%2F2019%2F11%2F14%2Fubuntu%E5%8D%87%E7%BA%A7cmake%2F</url>
    <content type="text"><![CDATA[去github下载最新版本或要升级的版本https://github.com/Kitware/CMake/releases这里有所有的发布版可以下载一个sh文件，运行sh文件相当于解压，比如cmake-3.15.5-Linux-x86_64.shwget下载特别慢，chrome插件chrono下载速度很快，其实在很多下载上它都更快，在可能的情况下尽量选它。 解压1sh cmake-3.15.5-Linux-x86_64.sh 移动1sudo mv cmake-3.15.5-Linux-x86_64 &#x2F;opt&#x2F;cmake-3.15.5 需要管理员权限 建立软连接1sudo ln -sf &#x2F;opt&#x2F;cmake-3.15.5&#x2F;bin&#x2F;* &#x2F;usr&#x2F;bin&#x2F; 同样，管理员权限 验证1234$cmake --versioncmake version 3.15.5CMake suite maintained and supported by Kitware (kitware.com&#x2F;cmake).]]></content>
      <tags>
        <tag>ubuntu</tag>
        <tag>cmake</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对编程方式的思考总结]]></title>
    <url>%2F2019%2F11%2F13%2F%E5%AF%B9%E7%BC%96%E7%A8%8B%E6%96%B9%E5%BC%8F%E7%9A%84%E6%80%9D%E8%80%83%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[可以采用tfjs-example里的一些组织特点，比如abalone-node，将每一个函数写成一个js，对外暴露接口，这样容易修改，看上去也十分简洁规范。 老博客地址：https://www.jianshu.com/u/1c73a3a8ae2d新博客地址：https://inspiring26.github.io/]]></content>
      <tags>
        <tag>总结</tag>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在node交互模式下怎么导入tf]]></title>
    <url>%2F2019%2F11%2F13%2F%E5%9C%A8node%E4%BA%A4%E4%BA%92%E6%A8%A1%E5%BC%8F%E4%B8%8B%E6%80%8E%E4%B9%88%E5%AF%BC%E5%85%A5tf%2F</url>
    <content type="text"><![CDATA[1import * as tf from &#39;@tensorflow&#x2F;tfjs&#39;;等方式会在*处报错正确的导入方式是使用require()1const tf &#x3D; require(&#39;@tensorflow&#x2F;tfjs-node&#39;);或者1const tf &#x3D; require(&#39;@tensorflow&#x2F;tfjs-node&#39;);也可以导入gpu版的 老博客地址：https://www.jianshu.com/u/1c73a3a8ae2d新博客地址：https://inspiring26.github.io/]]></content>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[base64]]></title>
    <url>%2F2019%2F11%2F07%2Fbase64%2F</url>
    <content type="text"><![CDATA[base64 是一种用64个字符表示二进制数据的方法。包括A-Z、a-z、0-9，这样共有62个，另外两个在不同的系统中不同，不用关心。2**6=64,所以6个比特才能表示一个字符。字节和比特的关系是1字节等于8比特。所以3字节可以表示3*8/6=4个字符。即一个字节可以表示一个字符多，三个字节可以表示四个字符。 base64常用来表示、传输、存储一些二进制数据，常用于邮件、xml等。]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[下载电影的一般方法]]></title>
    <url>%2F2019%2F11%2F06%2F%E4%B8%8B%E8%BD%BD%E7%94%B5%E5%BD%B1%E7%9A%84%E4%B8%80%E8%88%AC%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[打开google搜1电影名字 空格 80s80s有多个网站，一般会有几个能下的 如果80s没有就把关键字中的80s换成“电影天堂，人人，影视，迅雷，磁力链”等试试]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用python建立两台电脑之间的连接]]></title>
    <url>%2F2019%2F11%2F05%2F%E4%BD%BF%E7%94%A8python%E5%BB%BA%E7%AB%8B%E4%B8%A4%E5%8F%B0%E7%94%B5%E8%84%91%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BF%9E%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[只需要使用python的socket库就可以建立两台电脑的数据通信选择主机和端口选择一个电脑以它的端口作为交换的点，所有的数据都往这个点发送，或从这个点获取。通常选服务器的端口作交换数据的地点，当然选客户端的端口也完全不影响。比如我选的是服务器的端口，需要在server.bind() 里传入1(&quot;192.168.2.38&quot;,5016)一旦一个使用bind绑定本机ip和端口了，另一个电脑只需要使用client.connect(),传入相同参数元组建立连接就可以了1(&quot;192.168.2.38&quot;,5016)这时使用1netstat -anp | grep 5016指令查看端口情况就可以看到一个ip在监听该ip下的这个端口，另一个ip的某个端口在和该端口建立了连接12tcp 0 0 192.168.2.38:5016 0.0.0.0:* LISTEN 16062&#x2F;python3 tcp 0 0 192.168.2.38:5016 192.168.3.43:56202 ESTABLISHED 16062&#x2F;python3上面结果的意思是：0.0.0.0:*，也就是本机在监听192.168.2.38:5016192.168.3.43:56202和192.168.2.38:5016建立了连接 建立连接&amp;发送接收信息服务器和客户端的控制变量是通过123server &#x3D; socket.socket()或client &#x3D; socket.socket()建立的。服务器段使用server.listen()监听端口，使用conn,addr=server.accept()确认连接，使用data = conn.recv(1024)接收数据，使用conn.send()发送数据。 客户端少一条，在三次握手中它只主动发起一次请求。客户端使用client.connect(())建立连接，使用client.recv(1024)接收数据，使用client.send()发送数据。 完整代码1234567891011import socketserver &#x3D; socket.socket()server.bind((&quot;192.168.1.105&quot;,6969)) #绑定要监听的端口portserver.listen() # 监听print(&#39;waiting the call&#39;)conn,addr &#x3D; server.accept() # 等电话打进来，并且返回连接对象，print(conn)print(&#39;the call has comming&#39;)data &#x3D; conn.recv(1024) #接收客户端的消息，这里是一个字符串print(&#39;data:&#39;,data.decode()) # 将接受的数据进行解码conn.send(data.upper()) # 将字符串变成大写后发生给客户端 12345678import socketclient &#x3D; socket.socket() # 有一些默认参数，即可使用ipv4，这一句是声明socket类型和返回socket连接对象client.connect((&quot;192.168.1.105&quot;,6969)) # 建立连接：传入服务器端IP号和要连接的应用程序的端口号#client.send(b&#39;Hello&#39;) # 这里只能发生字节流信息，否则报错client.send(&#39;我是Hello&#39;.encode(encoding&#x3D;&#39;utf-8&#39;)) # 需要变成utf-8编码形式data &#x3D; client.recv(1024) #客户端可以接收服务器端的消息print(data.decode())client.close()]]></content>
      <tags>
        <tag>python</tag>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[添加捷径的方式]]></title>
    <url>%2F2019%2F11%2F01%2F%E6%B7%BB%E5%8A%A0%E6%8D%B7%E5%BE%84%E7%9A%84%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[如果在捷径社区无法直接安装可以先分享到微信 再跳转safari然后就可以安装了]]></content>
      <tags>
        <tag>iphone</tag>
        <tag>捷径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重庆公交刷手机]]></title>
    <url>%2F2019%2F11%2F01%2F%E9%87%8D%E5%BA%86%E5%85%AC%E4%BA%A4%E5%88%B7%E6%89%8B%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[这里指的是Apple Pay借记卡不行京东闪付不行信用卡直接添加可以]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写博客较好的方法]]></title>
    <url>%2F2019%2F11%2F01%2F%E5%86%99%E5%8D%9A%E5%AE%A2%E8%BE%83%E5%A5%BD%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[用随身的备忘录等工具先快速记录大概想法，空了，经过编辑修改后再用专门的工具创建发布。 写的环境一定要方便。感觉终端和sublime下写都没有备忘录随意方便。]]></content>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo的markdown里下划线也是有含义的]]></title>
    <url>%2F2019%2F11%2F01%2Fhexo%E7%9A%84markdown%E9%87%8C%E4%B8%8B%E5%88%92%E7%BA%BF%E4%B9%9F%E6%98%AF%E6%9C%89%E5%90%AB%E4%B9%89%E7%9A%84%2F</url>
    <content type="text"><![CDATA[需要使用转义符右斜杠]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python的引用方式]]></title>
    <url>%2F2019%2F11%2F01%2Fpython%E7%9A%84%E5%BC%95%E7%94%A8%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1from data import aclass data是当前目录下的文件夹aclass 在data文件夹里的__init__.py文件里__init__.py的作用是可以看作是aclass文件夹的基本/默认py文件，有它就可以把data文件夹看作一个py文件。另一个好处是，在__init__.py使用from .aae import bb，这样就把data文件夹下的所有类聚合到一起了。]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ios13允许不受信任的快捷指令是灰色的解决办法]]></title>
    <url>%2F2019%2F10%2F31%2Fios13%E5%85%81%E8%AE%B8%E4%B8%8D%E5%8F%97%E4%BF%A1%E4%BB%BB%E7%9A%84%E5%BF%AB%E6%8D%B7%E6%8C%87%E4%BB%A4%E6%98%AF%E7%81%B0%E8%89%B2%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[使用捷径社区安装快捷指令时，跳转后无法安装，设置中开关是灰色的，其实只要打开快捷指令随便运行一个，就可以输入密码设置打开安装不受信任快捷指令功能了。]]></content>
      <tags>
        <tag>iphone</tag>
        <tag>ios13</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pytorch把load的数据map到cpu上]]></title>
    <url>%2F2019%2F10%2F30%2Fpytorch%E6%8A%8Aload%E7%9A%84%E6%95%B0%E6%8D%AEmap%E5%88%B0cpu%E4%B8%8A%2F</url>
    <content type="text"><![CDATA[12checkpoint &#x3D; torch.load(&quot;checkpoint.pth&quot;, map_location&#x3D;torch.device(&#39;cpu&#39;))model.load_state_dict(checkpoint[&quot;state_dict&quot;]) 第二句更具情况可有可无。]]></content>
      <tags>
        <tag>pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[就一万年啊]]></title>
    <url>%2F2019%2F10%2F30%2F%E5%B0%B1%E4%B8%80%E4%B8%87%E5%B9%B4%E5%95%8A%2F</url>
    <content type="text"><![CDATA[“ 你数学那么好 你知道一万年是多久吗 ” “ 就一万年啊 ” “ 错 ” “ 一万年就是当有一个人跟你说 他想当正常人 然后离开了你 从那一天开始之后的每一天 就是一万年 ”]]></content>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安装nvidia-docker]]></title>
    <url>%2F2019%2F10%2F30%2F%E5%AE%89%E8%A3%85nvidia-docker%2F</url>
    <content type="text"><![CDATA[1234567sudo sudistribution&#x3D;$(. &#x2F;etc&#x2F;os-release;echo $ID$VERSION_ID)curl -s -L https:&#x2F;&#x2F;nvidia.github.io&#x2F;nvidia-docker&#x2F;gpgkey | sudo apt-key add -curl -s -L https:&#x2F;&#x2F;nvidia.github.io&#x2F;nvidia-docker&#x2F;$distribution&#x2F;nvidia-docker.list | sudo tee &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;nvidia-docker.listapt-get update &amp;&amp; apt-get install -y nvidia-container-toolkitsystemctl restart docker 以上是在ubuntu18.04，外部已配好cuda环境。]]></content>
      <tags>
        <tag>docker</tag>
        <tag>nvidia</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tornado跨域的解决方法]]></title>
    <url>%2F2019%2F10%2F29%2Ftornado%E8%B7%A8%E5%9F%9F%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[tornado h5跨域会报一种XMLHttpRequest错误，错误代码405。即使在tornado里设置了跨域，依然报错，这是因为h5跨域请求时要先发一个options请求，需要在Handler里处理一下options请求，具体代码如下：123456789101112131415161718192021222324252627class BaseHandler(tornado.web.RequestHandler): def set_default_headers(self): self.set_header(&#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;) self.set_header(&#39;Access-Control-Allow-Headers&#39;, &#39;*&#39;) self.set_header(&#39;Access-Control-Max-Age&#39;, 1000) self.set_header(&quot;Content-Type&quot;, &quot;application&#x2F;json; charset&#x3D;UTF-8&quot;) self.set_header(&#39;Access-Control-Allow-Methods&#39;, &#39;POST, GET, OPTIONS&#39;) self.set_header(&#39;Access-Control-Allow-Headers&#39;, &#39;authorization, Authorization, Content-Type, Access-Control-Allow-Origin, Access-Control-Allow-Headers, X-Requested-By, Access-Control-Allow-Methods&#39;)class MainHandler(BaseHandler): async def post(self): # 接收到图片的base64字符串 jsonbyte &#x3D; self.request.body.decode(&#39;utf8&#39;) jsondict &#x3D; json.loads(jsonbyte) picdata &#x3D; re.sub(&#39;^data:image&#x2F;.+;base64,&#39;, &#39;&#39;, jsondict[&quot;pic&quot;]+&quot;&#x3D;&#x3D;&quot;) r.sadd(&quot;palm&quot;,picdata) # 将图片转换成PIL读取的图片矩阵 binary_data &#x3D; base64.b64decode(picdata) img_data &#x3D; BytesIO(binary_data) imgtmp &#x3D; Image.open(img_data).convert(&quot;RGB&quot;) res &#x3D; await predictHandler(imgtmp) self.finish(res)#finish方法也是调用的write方法 async def options(self): self.finish()options方式请求只要通了就行，options请求之后就是正常的post请求了。]]></content>
      <tags>
        <tag>tornado</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[各个常用工具的中英文文档]]></title>
    <url>%2F2019%2F10%2F29%2F%E5%90%84%E4%B8%AA%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%9A%84%E4%B8%AD%E8%8B%B1%E6%96%87%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[docker 英文https://docs.docker.com/engine/reference/commandline/docker/python 英文https://docs.python.org/3.7/ python 中文https://docs.python.org/zh-cn/3.7/ pytorch 英文https://pytorch.org/docs/stable/nn.html#linear pytorch 中文https://pytorch-cn.readthedocs.io/zh/latest/package_references/torch-nn/#linear-layers sklearn 英文https://scikit-learn.org/stable/modules/classes.html sklearn 中文https://sklearn.apachecn.org/docs/0.21.3/ numpy 英文https://docs.scipy.org/doc/numpy/reference/ numpy 中文https://www.numpy.org.cn/user/ pandas 英文https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html pandas 中文https://www.pypandas.cn/docs/ matplotlib 英文https://matplotlib.org/py-modindex.html matplotlib 中文https://www.matplotlib.org.cn/deep/ pillow 英文https://pillow.readthedocs.io/en/latest/ pillow 中文https://pillow-zh-cn.readthedocs.io/zh_CN/latest/ tornado 英文https://www.tornadoweb.org/en/stable/index.html tornado 中文https://tornado-zh.readthedocs.io/zh/latest/]]></content>
      <tags>
        <tag>文档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在使用PIL读取图片后最好都加一个转换成RGB的函数，保证是三通道]]></title>
    <url>%2F2019%2F10%2F29%2F%E5%9C%A8%E4%BD%BF%E7%94%A8PIL%E8%AF%BB%E5%8F%96%E5%9B%BE%E7%89%87%E5%90%8E%E6%9C%80%E5%A5%BD%E9%83%BD%E5%8A%A0%E4%B8%80%E4%B8%AA%E8%BD%AC%E6%8D%A2%E6%88%90RGB%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%8C%E4%BF%9D%E8%AF%81%E6%98%AF%E4%B8%89%E9%80%9A%E9%81%93%2F</url>
    <content type="text"><![CDATA[有些图片打开了不是三通道，会导致输入数据维度不匹配，最好加一个转换，已经是RGB的就不会转换，因此也不影响速度。1imgtmp &#x3D; Image.open(img_data).convert(&quot;RGB&quot;)]]></content>
      <tags>
        <tag>深度学习</tag>
        <tag>PIL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker中执行多个指令的方法]]></title>
    <url>%2F2019%2F10%2F28%2Fdocker%E4%B8%AD%E6%89%A7%E8%A1%8C%E5%A4%9A%E4%B8%AA%E6%8C%87%E4%BB%A4%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[在Dockerfile中这么写：1234567FROM face_pytorch:latestWORKDIR &#x2F;face_version1EXPOSE 5015CMD [&quot;sh&quot;,&quot;auto.sh&quot;]在auto.sh中设置多个要执行的命令，如启动redis、运行程序、定期保存文件123456789101112131415nohup .&#x2F;redis-5.0.5&#x2F;src&#x2F;redis-server &gt; myredis.txt 2&gt;&amp;1 &amp;echo &quot;nohup redis-server complete!&quot;nohup python palm_re_v3.py &gt; mypalmpy.txt 2&gt;&amp;1 &amp;echo &quot;nohup python palm_re_v3.py complete!&quot;thetime&#x3D;$(date &quot;+%H%M&quot;) # the time is UTC0 not UTC8while truedo thetime&#x3D;$(date &quot;+%M&quot;) if [ $thetime &#x3D; &#39;00&#39; ] then echo &quot;save pics every hour&quot; python save_palm_pics.py fidone]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cpu下批处理居然比逐个处理时间更长]]></title>
    <url>%2F2019%2F10%2F28%2Fcpu%E4%B8%8B%E6%89%B9%E5%A4%84%E7%90%86%E5%B1%85%E7%84%B6%E6%AF%94%E9%80%90%E4%B8%AA%E5%A4%84%E7%90%86%E6%97%B6%E9%97%B4%E6%9B%B4%E9%95%BF%2F</url>
    <content type="text"><![CDATA[测试在cpu下一次预测一个图片和一次预测两个消耗时间的对比。实验中有两个模型，也就是说每个预测里面预测了两次。实验部分代码：123456789101112131415161718192021222324async def predictHandler3(): global pic_dict,pic_dict_res keylist &#x3D; list(pic_dict.keys()) keylist2&#x3D;list(pic_dict.keys())*2 print(&quot;keylist&quot;,keylist) print(&quot;keylist2&quot;,keylist2) time1 &#x3D; time.time() img &#x3D; [transform(pic_dict[_]).numpy().tolist() for _ in keylist] img &#x3D; torch.FloatTensor(img).cpu() with torch.no_grad(): outputs1 &#x3D; palmmodel(img) outputs2 &#x3D; handmodel(img) time2 &#x3D; time.time() print(time2-time1) time3 &#x3D; time.time() img &#x3D; [transform(pic_dict[_]).numpy().tolist() for _ in keylist2] img &#x3D; torch.FloatTensor(img).cpu() with torch.no_grad(): outputs1 &#x3D; palmmodel(img) outputs2 &#x3D; handmodel(img) time4 &#x3D; time.time() print(time4-time3)然而在gpu上则快非常多。 结论在cpu下进行推理不用考虑使用批处理。在gpu下使用批处理提升巨大，在必要的情况下可以考虑。]]></content>
      <tags>
        <tag>pytorch</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[配置tornado+pytorch的docker部署环境]]></title>
    <url>%2F2019%2F10%2F28%2F%E9%85%8D%E7%BD%AEtornado-pytorch%E7%9A%84docker%E9%83%A8%E7%BD%B2%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[拉去指定docker镜像（目前pytorch支持到pytorch1.3，python3.7）1docker pull python:3.7运行容器1docker run -dit python:3.7进入容器 123docker ps#59fe58579fd2 python:3.7 &quot;bash&quot; 35 minutes ago docker exec -it 59fe bash 配置环境12345python -V#Python 3.7.5pip3 instll -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple torch&#x3D;&#x3D;1.3.0+cpu torchvision&#x3D;&#x3D;0.4.1+cpu -f https:&#x2F;&#x2F;download.pytorch.org&#x2F;whl&#x2F;torch_stable.htmlpip3 instll -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple tornado redis pillow efficientnet_pytorch 此外，py文件中torch.load()要添加1,map_location&#x3D;torch.device(&#39;cpu&#39;)从而运行在cpu环境下。 安装redis数据库apt不能用临时源，且为了安装最新版本，从源文件编译安装12345wget -c http:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;redis-5.0.5.tar.gztar xzf redis-5.0.5.tar.gzcd redis-5.0.5make 启动redis123cd src&#x2F;nohup .&#x2F;redis-server &amp;.&#x2F;redis-cli]]></content>
      <tags>
        <tag>pytorch</tag>
        <tag>docker</tag>
        <tag>redis</tag>
        <tag>tornado</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python的字典、数组等基本机构可以存各种各样的数据结构的]]></title>
    <url>%2F2019%2F10%2F24%2Fpython%E7%9A%84%E5%AD%97%E5%85%B8%E3%80%81%E6%95%B0%E7%BB%84%E7%AD%89%E5%9F%BA%E6%9C%AC%E6%9C%BA%E6%9E%84%E5%8F%AF%E4%BB%A5%E5%AD%98%E5%90%84%E7%A7%8D%E5%90%84%E6%A0%B7%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%2F</url>
    <content type="text"><![CDATA[比如python自带的字典里，可以存numpy.ndarray类型数据、迭代等，这可能是因为python存的都是对一个数据的引用，所以可以存很多类型。]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis集合set主要功能]]></title>
    <url>%2F2019%2F10%2F24%2Fredis%E9%9B%86%E5%90%88set%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[SADD时间复杂度O(1)往set里添加元素，已有则忽略。SCARD查看指定key下的元素个数，这个比较常用SDIFF1SDIFF key1 key2找出第一个key中不在第二个key里的元素SDIFFSTORE 1SDIFFSTORE key key1 key2 将第一个key中不在第二个key的元素保存到新key下 SINTER1SINTER key1 key2 找出两个key中共同的元素 SINTERSTORE1SINTERSTORE key key1 key2 同理，保存这个共同的元素到新key SISMEMBER字面意思 is member查看是否在某个key里1SISMEMBER myset &quot;one&quot; SMEMBERS查看key下的所以元素，元素不多时常用，如果是遍历这不是个好方法，用迭代的方法更好。 SMOVE将指定元素从一个key移动到另一个key SPOP从set里随机的移除元素，注意是随机的 SRANDMEMBER从set里随机的获取一个或多个元素 SREM从set中移除指定元素，这个通常也是常用的 SUNION可以理解为合并两个set SUNIONSTORE合并两个set并保存在新key下]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tornado高并发使用redis线程池与不使用的对比]]></title>
    <url>%2F2019%2F10%2F24%2Ftornado%E9%AB%98%E5%B9%B6%E5%8F%91%E4%BD%BF%E7%94%A8redis%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%8E%E4%B8%8D%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AF%B9%E6%AF%94%2F</url>
    <content type="text"><![CDATA[使用的是siege进行的压测： 从图上可以看到对于高并发使用线程池后在各项响应时间上都有提升的。可见在高并发，尤其是和tornado搭配使用的时候务必使用redis且用线程池。tornado和redis有很多相似的地方比如都是单线程，都是非阻塞IO。它两个应该配合使用，应该作为在相应方面的主要工具，毕竟速度越快越好。]]></content>
      <tags>
        <tag>python</tag>
        <tag>redis</tag>
        <tag>tornado</tag>
        <tag>siege</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[部署深度学习模型的总结与新思考]]></title>
    <url>%2F2019%2F10%2F24%2F%E9%83%A8%E7%BD%B2%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%80%BB%E7%BB%93%E4%B8%8E%E6%96%B0%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[使用异步非阻塞服务器可以同时响应较多的请求。同时，可以把写操作先存内存数据库，每小时或其他时长写到硬盘一次。tornado不用再使用WSGI服务器了，从基础上保证比较快。如果是使用flask的话，还要使用一个WSGI服务器才能保证速度。 新想法将图片矩阵传入redis，设立一个异步调用，当传入数据后就发起调用预测函数。对预测函数来说，如果能读到数据就放入模型中跑，读不到数据说明在别的并发请求中已经将该数据处理了。 思考2由于存入redis，数组需要序列化和反序列化，可能存放在一个全局变量中更快。 实际测试过以后，没有同时读取两个图片进行预测的情况，都是单个图片的。难道是那几十个并发放在1000ms内被分的还是很散的？]]></content>
      <tags>
        <tag>pytorch</tag>
        <tag>深度学习</tag>
        <tag>思考</tag>
        <tag>keras</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis全局访问]]></title>
    <url>%2F2019%2F10%2F24%2Fredis%E5%85%A8%E5%B1%80%E8%AE%BF%E9%97%AE%2F</url>
    <content type="text"><![CDATA[要修改配置bind只能在配置文件中修改修改指令1sudo vim &#x2F;etc&#x2F;redis&#x2F;redis.conf在4%左右的位置将原bind修改为：12#bind 127.0.0.1 ::1bind 0.0.0.0重启redis1&#x2F;etc&#x2F;init.d&#x2F;redis-server restart]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tornado从tornado.web.RequestHandler类继承下来的Handler类的一些基本方法]]></title>
    <url>%2F2019%2F10%2F23%2Ftornado%E4%BB%8Etornado-web-RequestHandler%E7%B1%BB%E7%BB%A7%E6%89%BF%E4%B8%8B%E6%9D%A5%E7%9A%84Handler%E7%B1%BB%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1Most of the work of a Tornado web application is done in subclasses of RequestHandler.Tornado Web应用程序的大部分工作都是在RequestHandler的子类中完成的。1The main entry point for a handler subclass is a method named after the HTTP method being handled:get(), post(), etc.处理程序子类的主要入口点是以处理HTTP方法命名的方法：get(), post()等。1Each handler may define one or more of these methods to handle different HTTP actions.每个处理程序可以定义一个或多个这些方法来处理不同的HTTP操作。1As described above, these methods will be called with arguments corresponding to the capturing groups of the routing rule that matched.如上所述，将使用与匹配的路由规则的捕获组相对应的参数来调用这些方法。 1Within a handler, call methods such as RequestHandler.render or RequestHandler.write to produce a response. 在处理程序中，调用诸如RequestHandler.render或RequestHandler.write之类的方法以产生响应。 ender()1render() loads a Template by name and renders it with the given arguments. render（）按名称加载模板，并使用给定的参数进行渲染。 write()1write() is used for non-template-based output; it accepts strings, bytes, and dictionaries (dicts will be encoded as JSON). write（）用于基于非模板的输出；它接受字符串，字节和字典（字典将被编码为JSON）。 1Many methods in RequestHandler are designed to be overridden in subclasses and be used throughout the application. It is common to define a BaseHandler class that overrides methods such as write_error and get_current_user and then subclass your own BaseHandler instead of RequestHandler for all your specific handlers. RequestHandler中的许多方法被设计为在子类中重写，并在整个应用程序中使用。定义一个BaseHandler类来覆盖诸如write_error和get_current_user之类的方法是很常见的，然后为您所有的特定处理程序创建您自己的BaseHandler而不是RequestHandler的子类。]]></content>
      <tags>
        <tag>python</tag>
        <tag>tornado</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[百度、google对个人站点的收录情况分析]]></title>
    <url>%2F2019%2F10%2F22%2F%E7%99%BE%E5%BA%A6%E3%80%81google%E5%AF%B9%E4%B8%AA%E4%BA%BA%E7%AB%99%E7%82%B9%E7%9A%84%E6%94%B6%E5%BD%95%E6%83%85%E5%86%B5%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[第一次把站点地图推送到百度、google是10-14，过了8天了。google收录的比较快，但是也是略有延后，也不是什么都收录。百度收录的更慢更少。]]></content>
      <tags>
        <tag>GitHub Pages</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python快速实现转置的两种方法]]></title>
    <url>%2F2019%2F10%2F22%2Fpython%E5%BF%AB%E9%80%9F%E5%AE%9E%E7%8E%B0%E8%BD%AC%E7%BD%AE%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一个比较少用但是要知道的是python自带的函数reversed12345&gt;&gt;&gt; aa&#x3D;[1,2,3,4,5]&gt;&gt;&gt; reversed(aa)&lt;list_reverseiterator object at 0x7f1e06712978&gt;&gt;&gt;&gt; list(reversed(aa))[5, 4, 3, 2, 1]第二个是修改步长为-112&gt;&gt;&gt; aa[::-1][5, 4, 3, 2, 1]]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python的glob模块]]></title>
    <url>%2F2019%2F10%2F21%2Fpython%E7%9A%84glob%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[python自带的glob模块可以获取指定文件夹的文件，可以使用简单的通配符去匹配。返回的结果只包含文件名的列表，不包含文件夹。123456&gt;&gt;&gt; import glob&gt;&gt;&gt; pics &#x3D; glob.glob(&quot;*.jpg&quot;)&gt;&gt;&gt; pics[:2][&#39;6300509598986346813_n.jpg&#39;, &#39;120A2FD38AAC66414265A657BCFDA175.jpg&#39;]&gt;&gt;&gt; len(pics)15如此一来，用python处理文件夹内的文件就非常方便了。 支持通配符操作，*,?,[]这三个通配符，代表0个或多个字符，?代表一个字符，[]匹配指定范围内的字符，如[0-9]匹配数字。 此外，调用glob.iglob可以返回一个迭代器。1f &#x3D; glob.iglob()使用通配符的一个示例：1234567&gt;&gt;&gt; import glob&gt;&gt;&gt; glob.glob(&#39;.&#x2F;[0-9].*&#39;)[&#39;.&#x2F;1.gif&#39;, &#39;.&#x2F;2.txt&#39;]&gt;&gt;&gt; glob.glob(&#39;*.gif&#39;)[&#39;1.gif&#39;, &#39;card.gif&#39;]&gt;&gt;&gt; glob.glob(&#39;?.gif&#39;)[&#39;1.gif&#39;]]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pytorch之model.eval]]></title>
    <url>%2F2019%2F10%2F18%2Fpytorch%E4%B9%8Bmodel-eval%2F</url>
    <content type="text"><![CDATA[在测试模型是需要用model.eval()使模型变为测试模式，主要是针对dropout和batch normalization在训练时和测试时不一样的情况 其实这么看来，加不加都可以，一般还是加上。]]></content>
      <tags>
        <tag>pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[怎么迁移hexo网站源文件夹到其他位置]]></title>
    <url>%2F2019%2F10%2F18%2F%E6%80%8E%E4%B9%88%E8%BF%81%E7%A7%BBhexo%E7%BD%91%E7%AB%99%E6%BA%90%E6%96%87%E4%BB%B6%E5%A4%B9%E5%88%B0%E5%85%B6%E4%BB%96%E4%BD%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[只需将node文件夹复制/移动到其他位置就可以了。比如我讲node文件夹从Downloads文件夹移动到～主目录下，并删除了文件夹名字中的版本号，复制的话可以正常运行，但是会重新生成hello world文章，可以通过将这个文章转换成草稿解决。移动的话，需要在~/.bashrc中重新export一下/path/node/bin然后source ~/.bashrc使之生效 不管复制还是移动都建议修改成新的位置]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo用vim编辑文章后无法hexo g]]></title>
    <url>%2F2019%2F10%2F18%2Fhexo%E7%94%A8vim%E7%BC%96%E8%BE%91%E6%96%87%E7%AB%A0%E5%90%8E%E6%97%A0%E6%B3%95hexo-g%2F</url>
    <content type="text"><![CDATA[用vim编辑hexo文章的时候，tags:后面必须空一格才能正常生成hexo文章。]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu环境变量]]></title>
    <url>%2F2019%2F10%2F18%2Fubuntu%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[作用于当前终端1export CLASS_PATH&#x3D;.&#x2F;***&#x2F;lib:&#x2F;***&#x2F;lib作用于当前用户123vim ~&#x2F;.bashrcexport CLASS_PATH&#x3D;.&#x2F;***&#x2F;lib:&#x2F;***&#x2F;lib 如果想立即生效1source ~&#x2F;.bashrc]]></content>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pytorch基本模型]]></title>
    <url>%2F2019%2F10%2F18%2Fpytorch%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[一个基本的线性回归模型12345678910class LinearRegression(nn.Module): def __init__(self): super(LinearRegression,self).__init__() self.linear &#x3D; nn.Linear(1,1)#一个输入一个输出，此外隐藏一个偏差，y&#x3D;ax+b def forward(self,x): out &#x3D; self.linear(x) return outmodel &#x3D; LinearRegression()至此一个最简单的pytorch模型就定义完了。]]></content>
      <tags>
        <tag>pytorch</tag>
        <tag>写写画画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pytorch之torch.utils.data.DataLoader]]></title>
    <url>%2F2019%2F10%2F17%2Fpytorch%E4%B9%8Btorch-utils-data-DataLoader%2F</url>
    <content type="text"><![CDATA[带入：1from torch.utils.data import DataLoader该类的基本参数：1class torch.utils.data.DataLoader(dataset, batch_size&#x3D;1, shuffle&#x3D;False, sampler&#x3D;None, num_workers&#x3D;0, collate_fn&#x3D;&lt;function default_collate&gt;, pin_memory&#x3D;False, drop_last&#x3D;False)数据加载器。组合数据集和采样器，并在数据集上提供单进程或多进程迭代器。 参数：12345678dataset (Dataset) – 加载数据的数据集。batch_size (int, optional) – 每个batch加载多少个样本(默认: 1)。shuffle (bool, optional) – 设置为True时会在每个epoch重新打乱数据(默认: False).sampler (Sampler, optional) – 定义从数据集中提取样本的策略。如果指定，则忽略shuffle参数。num_workers (int, optional) – 用多少个子进程加载数据。0表示数据将在主进程中加载(默认: 0)collate_fn (callable, optional) –pin_memory (bool, optional) –drop_last (bool, optional) – 如果数据集大小不能被batch size整除，则设置为True后可删除最后一个不完整的batch。如果设为False并且数据集的大小不能被batch size整除，则最后一个batch将更小。(默认: False) 总结主要用来将数据组织成可迭代的数据，同时打乱数据、指定批大小。]]></content>
      <tags>
        <tag>pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pytorch的torchvision.datasets.ImageFolder]]></title>
    <url>%2F2019%2F10%2F17%2Fpytorch%E7%9A%84torchvision-datasets-ImageFolder%2F</url>
    <content type="text"><![CDATA[导入：1from torchvision.datasets import ImageFolder常用的参数有：1ImageFolder(root&#x3D;&quot;root folder path&quot;, [transform, target_transform])方括号是可选参数通常使用transform，target_transform是对标签进行变换1234from torchvision import transformstransform&#x3D;transforms.Compose([transforms.Resize(224),transforms.ToTensor(),transforms.Normalize((0.5,0.5,0.5),(0.5,0.5,0.5))])metadata&#x3D;ImageFolder(root&#x3D;&quot;&#x2F;home&#x2F;h&#x2F;models&#x2F;公司项目&#x2F;4.手掌手相识别&#x2F;左右手数据&quot;, transform&#x3D;transform)它有三个成员变量：123.classes - 用一个list保存 类名.class_to_idx - 类名对应的 索引.imgs - 保存(img-path, class) tuple的list效果分别如下：1234567891011[&#39;右手&#39;, &#39;左手&#39;]&#123;&#39;右手&#39;: 0, &#39;左手&#39;: 1&#125;[(&#39;&#x2F;home&#x2F;h&#x2F;models&#x2F;公司项目&#x2F;4.手掌手相识别&#x2F;左右手数据&#x2F;右手&#x2F;palm_03PqxLsHfb.png&#39;, 0), (&#39;&#x2F;home&#x2F;h&#x2F;models&#x2F;公司项目&#x2F;4.手掌手相识别&#x2F;左右手数据&#x2F;右手&#x2F;palm_07K5FrWykv.png&#39;, 0), (&#39;&#x2F;home&#x2F;h&#x2F;models&#x2F;公司项目&#x2F;4.手掌手相识别&#x2F;左右手数据&#x2F;右手&#x2F;palm_08qhgOx7tF.png&#39;, 0), (&#39;&#x2F;home&#x2F;h&#x2F;models&#x2F;公司项目&#x2F;4.手掌手相识别&#x2F;左右手数据&#x2F;右手&#x2F;palm_09FOfDraXb.png&#39;, 0), (&#39;&#x2F;home&#x2F;h&#x2F;models&#x2F;公司项目&#x2F;4.手掌手相识别&#x2F;左右手数据&#x2F;右手&#x2F;palm_09wPmeWrE2.png&#39;, 0),直接打印metadata可以看到大致信息：123456789Dataset ImageFolder Number of datapoints: 5858 Root Location: &#x2F;home&#x2F;h&#x2F;models&#x2F;公司项目&#x2F;4.手掌手相识别&#x2F;左右手数据 Transforms (if any): Compose( Resize(size&#x3D;224, interpolation&#x3D;PIL.Image.BILINEAR) ToTensor() Normalize(mean&#x3D;(0.5, 0.5, 0.5), std&#x3D;(0.5, 0.5, 0.5)) ) Target Transforms (if any): None 补充由12345[(&#39;&#x2F;home&#x2F;h&#x2F;models&#x2F;公司项目&#x2F;4.手掌手相识别&#x2F;左右手数据&#x2F;右手&#x2F;palm_03PqxLsHfb.png&#39;, 0), (&#39;&#x2F;home&#x2F;h&#x2F;models&#x2F;公司项目&#x2F;4.手掌手相识别&#x2F;左右手数据&#x2F;右手&#x2F;palm_07K5FrWykv.png&#39;, 0), (&#39;&#x2F;home&#x2F;h&#x2F;models&#x2F;公司项目&#x2F;4.手掌手相识别&#x2F;左右手数据&#x2F;右手&#x2F;palm_08qhgOx7tF.png&#39;, 0), (&#39;&#x2F;home&#x2F;h&#x2F;models&#x2F;公司项目&#x2F;4.手掌手相识别&#x2F;左右手数据&#x2F;右手&#x2F;palm_09FOfDraXb.png&#39;, 0), (&#39;&#x2F;home&#x2F;h&#x2F;models&#x2F;公司项目&#x2F;4.手掌手相识别&#x2F;左右手数据&#x2F;右手&#x2F;palm_09wPmeWrE2.png&#39;, 0),可知，ImageFolder保存的是地址list不是具体图片，这就占用的内存就很小。下一步也是迭代一批图片才读取那批图片。]]></content>
      <tags>
        <tag>pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深度学习模型特点]]></title>
    <url>%2F2019%2F10%2F16%2F%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B%E7%89%B9%E7%82%B9%2F</url>
    <content type="text"><![CDATA[宽度模型拥有强大的记忆能力。深度模型具有很强的泛化能力。 可以把模型分成两部分，一部分作为另一部分的输入之一，从而使模型具有两者的优点。]]></content>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jupyter中下载pytorch自带数据集或其他外网数据集速度慢的解决办法]]></title>
    <url>%2F2019%2F10%2F15%2Fjupyter%E4%B8%AD%E4%B8%8B%E8%BD%BDpytorch%E8%87%AA%E5%B8%A6%E6%95%B0%E6%8D%AE%E9%9B%86%E6%88%96%E5%85%B6%E4%BB%96%E5%A4%96%E7%BD%91%E6%95%B0%E6%8D%AE%E9%9B%86%E9%80%9F%E5%BA%A6%E6%85%A2%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1!export https_proxy&#x3D;http:&#x2F;&#x2F;192.168.1.80:1080]]></content>
      <tags>
        <tag>pytorch</tag>
        <tag>jupyter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pytorch怎么finetuning]]></title>
    <url>%2F2019%2F10%2F15%2Fpytorch%E6%80%8E%E4%B9%88finetuning%2F</url>
    <content type="text"><![CDATA[可以在加载模型后，直接修改最后一层的结构。加载模型并查看网络结构123from torchvision import modelsmodel&#x3D;models.resnet18(pretrained&#x3D;True)model 部分结果为：12345678910111213141516171819202122(layer4): Sequential( (0): BasicBlock( (conv1): Conv2d(256, 512, kernel_size&#x3D;(3, 3), stride&#x3D;(2, 2), padding&#x3D;(1, 1), bias&#x3D;False) (bn1): BatchNorm2d(512, eps&#x3D;1e-05, momentum&#x3D;0.1, affine&#x3D;True, track_running_stats&#x3D;True) (relu): ReLU(inplace) (conv2): Conv2d(512, 512, kernel_size&#x3D;(3, 3), stride&#x3D;(1, 1), padding&#x3D;(1, 1), bias&#x3D;False) (bn2): BatchNorm2d(512, eps&#x3D;1e-05, momentum&#x3D;0.1, affine&#x3D;True, track_running_stats&#x3D;True) (downsample): Sequential( (0): Conv2d(256, 512, kernel_size&#x3D;(1, 1), stride&#x3D;(2, 2), bias&#x3D;False) (1): BatchNorm2d(512, eps&#x3D;1e-05, momentum&#x3D;0.1, affine&#x3D;True, track_running_stats&#x3D;True) ) ) (1): BasicBlock( (conv1): Conv2d(512, 512, kernel_size&#x3D;(3, 3), stride&#x3D;(1, 1), padding&#x3D;(1, 1), bias&#x3D;False) (bn1): BatchNorm2d(512, eps&#x3D;1e-05, momentum&#x3D;0.1, affine&#x3D;True, track_running_stats&#x3D;True) (relu): ReLU(inplace) (conv2): Conv2d(512, 512, kernel_size&#x3D;(3, 3), stride&#x3D;(1, 1), padding&#x3D;(1, 1), bias&#x3D;False) (bn2): BatchNorm2d(512, eps&#x3D;1e-05, momentum&#x3D;0.1, affine&#x3D;True, track_running_stats&#x3D;True) ) ) (avgpool): AdaptiveAvgPool2d(output_size&#x3D;(1, 1)) (fc): Linear(in_features&#x3D;512, out_features&#x3D;1000, bias&#x3D;True) 修改最后一层123import torch.nn as nnmodel.fc&#x3D;nn.Linear(512,100,bias&#x3D;True)model 修改后：12345678910111213141516171819202122(layer4): Sequential( (0): BasicBlock( (conv1): Conv2d(256, 512, kernel_size&#x3D;(3, 3), stride&#x3D;(2, 2), padding&#x3D;(1, 1), bias&#x3D;False) (bn1): BatchNorm2d(512, eps&#x3D;1e-05, momentum&#x3D;0.1, affine&#x3D;True, track_running_stats&#x3D;True) (relu): ReLU(inplace) (conv2): Conv2d(512, 512, kernel_size&#x3D;(3, 3), stride&#x3D;(1, 1), padding&#x3D;(1, 1), bias&#x3D;False) (bn2): BatchNorm2d(512, eps&#x3D;1e-05, momentum&#x3D;0.1, affine&#x3D;True, track_running_stats&#x3D;True) (downsample): Sequential( (0): Conv2d(256, 512, kernel_size&#x3D;(1, 1), stride&#x3D;(2, 2), bias&#x3D;False) (1): BatchNorm2d(512, eps&#x3D;1e-05, momentum&#x3D;0.1, affine&#x3D;True, track_running_stats&#x3D;True) ) ) (1): BasicBlock( (conv1): Conv2d(512, 512, kernel_size&#x3D;(3, 3), stride&#x3D;(1, 1), padding&#x3D;(1, 1), bias&#x3D;False) (bn1): BatchNorm2d(512, eps&#x3D;1e-05, momentum&#x3D;0.1, affine&#x3D;True, track_running_stats&#x3D;True) (relu): ReLU(inplace) (conv2): Conv2d(512, 512, kernel_size&#x3D;(3, 3), stride&#x3D;(1, 1), padding&#x3D;(1, 1), bias&#x3D;False) (bn2): BatchNorm2d(512, eps&#x3D;1e-05, momentum&#x3D;0.1, affine&#x3D;True, track_running_stats&#x3D;True) ) ) (avgpool): AdaptiveAvgPool2d(output_size&#x3D;(1, 1)) (fc): Linear(in_features&#x3D;512, out_features&#x3D;100, bias&#x3D;True) 设置转换图片参数12from torchvision import transformstransform&#x3D;transforms.Compose([transforms.Resize(224),transforms.ToTensor(),transforms.Normalize((0.5,0.5,0.5),(0.5,0.5,0.5))]) 加载pytorch自带数据12345678910import torchimport torchvisiontrain_set&#x3D;torchvision.datasets.CIFAR100(root&#x3D;&#39;.&#x2F;data&#39;, train&#x3D;True, download&#x3D;True, transform&#x3D;transform)trainloader&#x3D;torch.utils.data.DataLoader(train_set,batch_size&#x3D;32,shuffle&#x3D;True,num_workers&#x3D;0)test_set&#x3D;torchvision.datasets.CIFAR100(root&#x3D;&quot;.&#x2F;data&quot;,train&#x3D;False,download&#x3D;True,transform&#x3D;transform)testloader&#x3D;torch.utils.data.DataLoader(test_set,batch_size&#x3D;32,shuffle&#x3D;True,num_workers&#x3D;0)classes &#x3D; (&#39;plane&#39;, &#39;car&#39;, &#39;bird&#39;, &#39;cat&#39;, &#39;deer&#39;, &#39;dog&#39;, &#39;frog&#39;, &#39;horse&#39;, &#39;ship&#39;, &#39;truck&#39;) 设置模型的训练参数，finetuning时学习率小一点12345from torch import optimnet&#x3D;model.cuda()criterion&#x3D;nn.CrossEntropyLoss()optimizer&#x3D;optim.SGD(net.parameters(),lr&#x3D;0.001,momentum&#x3D;0.9) 训练123456789101112131415161718192021222324252627282930from torch.autograd import Variableimport timefor epoch in range(100): start &#x3D; time.time() running_loss&#x3D;0 for i,data in enumerate(trainloader,0): image,label&#x3D;data image&#x3D;image.cuda() label&#x3D;label.cuda() image&#x3D;Variable(image) label&#x3D;Variable(label) optimizer.zero_grad() outputs&#x3D;net(image) loss&#x3D;criterion(outputs,label) loss.backward() optimizer.step() running_loss+&#x3D;loss.data if i%100&#x3D;&#x3D;99: end&#x3D;time.time() print (&#39;[epoch %d,imgs %5d] loss: %.7f time: %0.3f s&#39;%(epoch+1,(i+1)*32,running_loss&#x2F;100,(end-start))) start&#x3D;time.time() running_loss&#x3D;0print (&quot;finish training&quot;)]]></content>
      <tags>
        <tag>pytorch</tag>
        <tag>finetuning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[torch.unsqueeze]]></title>
    <url>%2F2019%2F10%2F15%2Ftorch-unsqueeze%2F</url>
    <content type="text"><![CDATA[torch.unsqueeze()的作用是增加一个维度，常用的是将单张图片增加一个维度。这样才可以传入模型。1torch.unsqueeze(img,0)]]></content>
      <tags>
        <tag>pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网页显示没有空格复制有空格的解决办法]]></title>
    <url>%2F2019%2F10%2F14%2F%E7%BD%91%E9%A1%B5%E6%98%BE%E7%A4%BA%E6%B2%A1%E6%9C%89%E7%A9%BA%E6%A0%BC%E5%A4%8D%E5%88%B6%E6%9C%89%E7%A9%BA%E6%A0%BC%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[网页没有空格，复制有空格，常用的解决办法是在父结点加font-size:0;有一个好的辅助查看办法，inspect中编辑as html的方式去查看，我遇到的情况font-size:0;并不难解决，最终的解决办法是把整个&lt;td&gt;写成一行。]]></content>
      <tags>
        <tag>html</tag>
        <tag>flask</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[百度收录githubpages上hexo文章]]></title>
    <url>%2F2019%2F10%2F14%2F%E7%99%BE%E5%BA%A6%E6%94%B6%E5%BD%95githubpages%E4%B8%8Ahexo%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[在根目录安装1npm install hexo-baidu-url-submit --save在根目录的配置文件中添加12345baidu_url_submit: count: 1000 ## 可以写一个很大的数 host: https:&#x2F;&#x2F;inspiring26.github.io ## 在百度站长平台中注册的域名 token: your_token ## 请注意这是您的秘钥， 所以请不要把博客源代码发布在公众仓库里! path: baidu_urls.txt ## 文本文档的地址， 新链接会保存在此文本文档里 然后部署就可以了，可以在public文件夹看到生成的1baidu_urls.txt 更新上面方法依然不行，可能是没用到1type: baidu_url_submitter 最终解决办法：deploy.sh最后添加 1curl -H &#39;Content-Type:text&#x2F;plain&#39; --data-binary @public&#x2F;baidu_urls.txt &quot;http:&#x2F;&#x2F;data.zz.baidu.com&#x2F;urls?site&#x3D;inspiring26.github.io&amp;token&#x3D;&lt;你的tocken&gt;&quot; 这个代码在https://ziyuan.baidu.com/linksubmit/index的主动推送下。只要修改baidu_urls的路径就好了。返回结果： 1&#123;&quot;remain&quot;:9966,&quot;success&quot;:34&#125;]]></content>
      <tags>
        <tag>GitHub Pages</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[百度、google、bing收录github pages站点]]></title>
    <url>%2F2019%2F10%2F12%2F%E7%99%BE%E5%BA%A6%E3%80%81google%E3%80%81bing%E6%94%B6%E5%BD%95github-pages%E7%AB%99%E7%82%B9%2F</url>
    <content type="text"><![CDATA[由于Github Pages禁止的原因，百度、google、bing等搜索引擎都是不收录hexo-Github Pages创建的站点的，需要分别去每个搜索引擎提交站点。百度在themes/next/_config.yml中将google-site-verification和baidu-site-verification、bing-site-verification的值设置为true。 打开百度的站点提交地址http://ziyuan.baidu.com/site/index 一步步下去，由于hexo会修改根目录文件，文件验证会有问题，选择html标签验证。 修改themes/next/layout/_partials/head/head.swig中的元数据，baidu-site-verification对应的值。（ 一会儿google还要修改一次，bing目前没修改不知道有没有影响） 然后sh deploy.sh部署验证就可以了。 Googlegoole的方式类似，注意资源类型选网址前缀地址：https://www.google.com/webmasters/tools/home?hl=zh-CN bing用google帐号登录后可直接导入google的认证。地址：https://www.bing.com/webmaster/home/mysites 文章参考地址(关于站点地图的信息见这个链接)https://blog.csdn.net/qq_32454537/article/details/79482914 10.14更新文件验证方式或许可以把文件放在public文件夹(未验证)，因为pubic文件夹下的文件不会被修改。另外，由此可知：通过在public文件夹下放置文件、文件夹，就行成了一个类似ftp的下载站点。另外2，由于放在github pages上，速度依然不快，但是只要本地服务运行就可以本地访问，这就很快了。另外3，可以简单的运行hexo服务建立文件下载服务(需要输入完整的文件名，不可以查看目录)。 10.22更新bing不要忘了提交sitemap。]]></content>
      <tags>
        <tag>GitHub Pages</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[homepod功耗]]></title>
    <url>%2F2019%2F10%2F12%2Fhomepod%E5%8A%9F%E8%80%97%2F</url>
    <content type="text"><![CDATA[一般LED灯功耗 9-10w小米LED随身灯 额定电压5V 6颗0.2W的LED灯 额定功率1.2Whomepod 115v电压 50%音量 8.74w几分钟不用进入低功耗模式 1.71-1.76w中国交流电压220v，可能是对应数据的两倍，即 模式 功率 耗电 50%音量 17.48w 57.2小时一度电 低功耗模式 3.52w 284.09小时(11.8天)一度电 总之就是非常低了，一直开着，功耗可以忽略不计。]]></content>
      <tags>
        <tag>homepod</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[突然想到，手机远程发hexo上传图片的方式]]></title>
    <url>%2F2019%2F10%2F12%2F%E7%AA%81%E7%84%B6%E6%83%B3%E5%88%B0%EF%BC%8C%E6%89%8B%E6%9C%BA%E8%BF%9C%E7%A8%8B%E5%8F%91hexo%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E7%9A%84%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[手机可以通过vpn连到公司服务器，但是没法直接通过ios上的Terminal把图片传到服务器。可以通过其他的方式如网盘、邮件将图片传输上去，然而如果想保存到服务器硬盘就需要打开网页下载。（这一步也可以通过teamviewer等软件实现，但是很麻烦，需要操作屏幕下载）于是，考虑到可以将图片做成外链，一般的图床工具不太放心，希望放在自己的存储空间内。突然想到，不是可以传到github的空闲仓库嘛，然后就做成外链了，之前pac文件也是这么搞的。示例： 很喜欢吃这家的小面，但是老板比较任性，想开就开想关就关，完全看心情。]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>思考</tag>
        <tag>美食</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu卸载teamviewer]]></title>
    <url>%2F2019%2F10%2F12%2Fubuntu%E5%8D%B8%E8%BD%BDteamviewer%2F</url>
    <content type="text"><![CDATA[由于近期teamviewer后台服务器被黑，先卸载teamviewer。新闻链接ubuntu下卸载指令：1apt --purge remove teamviewer查看5938端口：1netstat -anp | grep 5938如果没有结果就表示成功卸载。]]></content>
      <tags>
        <tag>ubuntu</tag>
        <tag>teamviewer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[busuanzi阅读量统计在本地数据量很大的可能原因分析]]></title>
    <url>%2F2019%2F10%2F11%2Fbusuanzi%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%9C%A8%E6%9C%AC%E5%9C%B0%E6%95%B0%E6%8D%AE%E9%87%8F%E5%BE%88%E5%A4%A7%E7%9A%84%E5%8F%AF%E8%83%BD%E5%8E%9F%E5%9B%A0%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[一个可能的原因是它统计阅读量依据的是你当前的ip或者域名，当你在本地用默认的localhost时，肯定会上传很多次，如果你把localhost换成主机ip你会发现少了很多或者说正常了。另外，也可以用hexo s将网站部署在内网某个ip或者部署在远程服务器上。]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深度学习中常用的由label列表生成对应字典的演进过程]]></title>
    <url>%2F2019%2F10%2F11%2F%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E7%94%B1label%E5%88%97%E8%A1%A8%E7%94%9F%E6%88%90%E5%AF%B9%E5%BA%94%E5%AD%97%E5%85%B8%E7%9A%84%E6%BC%94%E8%BF%9B%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[生成式生成字典1234567891011121314151617181920&#123;_:1 for _ in list(counter.keys())&#125;&#123;&#39;纪念日&#39;: 1, &#39;女神节&#39;: 1, &#39;感恩节&#39;: 1, &#39;中秋节&#39;: 1, &#39;父亲节&#39;: 1, &#39;生子&#39;: 1, &#39;春节&#39;: 1, &#39;升学&#39;: 1, &#39;拜访&#39;: 1, &#39;母亲节&#39;: 1, &#39;儿童节&#39;: 1, &#39;教师节&#39;: 1, &#39;七夕&#39;: 1, &#39;乔迁&#39;: 1, &#39;情人节&#39;: 1, &#39;生日&#39;: 1, &#39;圣诞节&#39;: 1, &#39;新年&#39;: 1&#125; 想同时改变value值1234567891011121314151617181920&#123;x:y for x in list(counter.keys()) for y in range(len(list(counter.keys())))&#125;&#123;&#39;纪念日&#39;: 17, &#39;女神节&#39;: 17, &#39;感恩节&#39;: 17, &#39;中秋节&#39;: 17, &#39;父亲节&#39;: 17, &#39;生子&#39;: 17, &#39;春节&#39;: 17, &#39;升学&#39;: 17, &#39;拜访&#39;: 17, &#39;母亲节&#39;: 17, &#39;儿童节&#39;: 17, &#39;教师节&#39;: 17, &#39;七夕&#39;: 17, &#39;乔迁&#39;: 17, &#39;情人节&#39;: 17, &#39;生日&#39;: 17, &#39;圣诞节&#39;: 17, &#39;新年&#39;: 17&#125; 生成式不能同步遍历x y，再改进，通过zip将二者组合起来1234567891011121314151617181920&#123;_[0]:_[1] for _ in zip(list(counter.keys()),range(len(list(counter.keys()))))&#125;&#123;&#39;纪念日&#39;: 0, &#39;女神节&#39;: 1, &#39;感恩节&#39;: 2, &#39;中秋节&#39;: 3, &#39;父亲节&#39;: 4, &#39;生子&#39;: 5, &#39;春节&#39;: 6, &#39;升学&#39;: 7, &#39;拜访&#39;: 8, &#39;母亲节&#39;: 9, &#39;儿童节&#39;: 10, &#39;教师节&#39;: 11, &#39;七夕&#39;: 12, &#39;乔迁&#39;: 13, &#39;情人节&#39;: 14, &#39;生日&#39;: 15, &#39;圣诞节&#39;: 16, &#39;新年&#39;: 17&#125;]]></content>
      <tags>
        <tag>深度学习</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[train_test_split的变更]]></title>
    <url>%2F2019%2F10%2F11%2Ftrain-test-split%E7%9A%84%E5%8F%98%E6%9B%B4%2F</url>
    <content type="text"><![CDATA[sklearn的划分数据集工具train_test_split，由sklearn.cross_validation.train_test_split变更为sklearn.model_selection.train_test_split1trainset, testset &#x3D; train_test_split(img_data, test_size &#x3D; 0.2)或1X_train,X_test, y_train, y_test &#x3D;train_test_split(train_data,train_target,test_size&#x3D;0.2, random_state&#x3D;0) train_data：去除label的数据集！！！！train_target：label集合！！！！test_size：样本占比，如果是整数的话就是样本的数量random_state：是随机数的种子。随机数种子：其实就是该组随机数的编号，在需要重复试验的时候，保证得到一组一样的随机数。比如你每次都填1，其他参数一样的情况下你得到的随机数组是一样的。但填0或不填，每次都会不一样。]]></content>
      <tags>
        <tag>sklearn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub Pages使用限制]]></title>
    <url>%2F2019%2F10%2F11%2FGitHub-Pages%E4%BD%BF%E7%94%A8%E9%99%90%E5%88%B6%2F</url>
    <content type="text"><![CDATA[一致会在网上断断续续看到GitHub Pages的空间和流量限制，现在GitHub Pages官网找到具体内容。原文：123456789101112Usage limitsGitHub Pages sites are subject to the following usage limits:GitHub Pages source repositories have a recommended limit of 1GB. For more information, see &quot;What is my disk quota?&quot;Published GitHub Pages sites may be no larger than 1 GB.GitHub Pages sites have a soft bandwidth limit of 100GB per month.GitHub Pages sites have a soft limit of 10 builds per hour.If your site exceeds these usage quotas, we may not be able to serve your site, or you may receive a polite email from GitHub Support or GitHub Premium Support suggesting strategies for reducing your site&#39;s impact on our servers, including putting a third-party content distribution network (CDN) in front of your site, making use of other GitHub features such as releases, or moving to a different hosting service that might better fit your needs.大意：1231.GitHub Pages的源文件仓库容量限制为1G2.GitHub Pages站点大小不能超过1G3.每个月的带宽为100G4.每小时只能更新10次 地址https://help.github.com/en/articles/about-github-pages]]></content>
      <tags>
        <tag>GitHub Pages</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pytorch保存模型和保存模型参数]]></title>
    <url>%2F2019%2F10%2F11%2Fpytorch%E4%BF%9D%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%92%8C%E4%BF%9D%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[保存、加载模型12torch.save(modelname, &#39;model.pkl&#39;)model &#x3D; torch.load(&#39;model.pkl&#39;)特点使用时不需要定义网络模型，同时也不方便调整网络结构 保存、加载模型参数12torch.save(modelname.state_dict(), &#39;params.pkl&#39;)modelname.load_state_dict(torch.load(&#39;params.pkl&#39;)) 特点需要自己定义网络，并且其中的参数名称与结构要与保存的模型中的一致（可以定义部分网络，比如只使用VGG的前几层），相对灵活，便于对网络进行修改。]]></content>
      <tags>
        <tag>pytorch</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pandas选取特定行和排除特定行]]></title>
    <url>%2F2019%2F10%2F11%2Fpandas%E9%80%89%E5%8F%96%E7%89%B9%E5%AE%9A%E8%A1%8C%E5%92%8C%E6%8E%92%E9%99%A4%E7%89%B9%E5%AE%9A%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[pandas只有isin()方法，没有isnotin()方法。我们要选取特定行，只需1df[df.&lt;列名&gt;.isin([&quot;&quot;,&quot;&quot;])]要排除特定行时，需要间接的修改isin的参数列表123# 错误的isin_list &#x3D; list(set(df[&quot;列名&quot;])).remove(&quot;&quot;).remove(&quot;&quot;)df[df.&lt;列名&gt;.isin(isin_list)]注意，即使列名是中文，在第二行的筛选中也不能加引号，正确的是123# remove使用错误isin_list &#x3D; list(set(df[&quot;列名&quot;])).remove(&quot;&quot;).remove(&quot;&quot;)df[df.列名.isin(isin_list)] 注意remove()对列表处理返回结果NoneType类型的，也就是说不能用赋值的方式去传递结果，而是在列表上直接操作1list.remove(&quot;&quot;)同时，因为结果是NoneType类型，也不能个连续使用.remove(“”)。所有返回结果是NoneType类型的都不能赋值及连续使用。一个好的解决办法是使用生成式1[list.remove(_) for _ in anotherlist]当有多个list要移除相同的元素时可以使用1[(isin_list1.remove(_),isin_list2.remove(_)) for _ in [&quot;&quot;,&quot;&quot;]]而不可以使用1[isin_list1.remove(_),isin_list2.remove(_) for _ in [&quot;&quot;,&quot;&quot;]]这是因为生成式一个元素里含有多个子元素时，必须要用列表或者元组等表示为整体上的一个元素]]></content>
      <tags>
        <tag>python</tag>
        <tag>pandas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pandas删除含NaN的行]]></title>
    <url>%2F2019%2F10%2F11%2Fpandas%E5%88%A0%E9%99%A4%E5%90%ABNaN%E7%9A%84%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[DataFrame下面有一个dropna函数可以去掉所有含NaN的行。1df1.head() 1df1.dropna().head()]]></content>
      <tags>
        <tag>python</tag>
        <tag>pandas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pandas的usecols不能指定[A,B,C]]]></title>
    <url>%2F2019%2F10%2F11%2Fpandas%E7%9A%84usecols%E4%B8%8D%E8%83%BD%E6%8C%87%E5%AE%9A-A-B-C%2F</url>
    <content type="text"><![CDATA[pandas的usecols不能指定[“A”,”B”,”C”].如果使用列表的话，需要指定对应的索引数值，如12sheet_name&#x3D;&quot;Sheet3&quot;,usecols&#x3D;[1,6]sheet_name&#x3D;&quot;人工打标签(新)&quot;,usecols&#x3D;[1,2]]]></content>
      <tags>
        <tag>python</tag>
        <tag>pandas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[当断则断]]></title>
    <url>%2F2019%2F10%2F11%2F%E5%BD%93%E6%96%AD%E5%88%99%E6%96%AD%2F</url>
    <content type="text"><![CDATA[我为禽言仔细思，不知何事错当时。 前机多为因循误，后悔皆以决断迟。]]></content>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo开启busuanzi阅读量统计]]></title>
    <url>%2F2019%2F10%2F10%2Fhexo%E5%BC%80%E5%90%AFbusuanzi%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[在next主题6以上的版本的配置文件_config.yml中，有12345678busuanzi_count: enable: false total_visitors: true total_visitors_icon: user total_views: true total_views_icon: eye post_views: true post_views_icon: eye参数。将其中的enable 参数改成true即可。在本地测试环境数值会很大，部署到线上就正常了。]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python tqdm库]]></title>
    <url>%2F2019%2F10%2F10%2Fpython-tqdm%E5%BA%93%2F</url>
    <content type="text"><![CDATA[Tqdm 是 Python 进度条库，可以在 Python 长循环中添加一个进度提示信息用法：tqdm(iterator)可以用trange替代range12345678910111213# 方法1：import timefrom tqdm import tqdm for i in tqdm(range(100)): time.sleep(0.01)# 方法2：import timefrom tqdm import trangefor i in trange(100): time.sleep(0.01) 结果：12100%|██████████| 100&#x2F;100 [00:01&lt;00:00, 97.03it&#x2F;s]100%|██████████| 100&#x2F;100 [00:01&lt;00:00, 97.30it&#x2F;s] 可以为进度条设置描述相当于下面的&quot;Processing %s&quot;是额外加载每一行的12345678import timefrom tqdm import tqdmpbar &#x3D; tqdm([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]) for char in pbar: pbar.set_description(&quot;Processing %s&quot; % char) time.sleep(1)#pbar.close() 不需要结果：1Processing d: 100%|██████████| 4&#x2F;4 [00:04&lt;00:00, 1.00s&#x2F;it] 使用update()控制更新频率1234567891011121314151617import timefrom tqdm import tqdm# 一共200个，每次更新10，一共更新20次with tqdm(total&#x3D;200) as pbar: for i in range(20): pbar.update(10) time.sleep(0.1)#方法2：pbar &#x3D; tqdm(total&#x3D;200) for i in range(20): pbar.update(10) time.sleep(0.1)# with is also optional (you can just assign tqdm() to a variable, but in this case don&#39;t forget to del or close() at the endpbar.close() 结果：12100%|██████████| 200&#x2F;200 [00:01&lt;00:00, 98.18it&#x2F;s] 100%|██████████| 200&#x2F;200 [00:01&lt;00:00, 98.02it&#x2F;s]用了with就不用在结束时使用close，没用with的情况下还要额外使用close()的。 参考链接1.https://github.com/tqdm/tqdm2.https://www.jianshu.com/p/21cf48be6bf6]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python读取数据时跳过空行]]></title>
    <url>%2F2019%2F10%2F10%2Fpython%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE%E6%97%B6%E8%B7%B3%E8%BF%87%E7%A9%BA%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[123for line in f: if not line: continue 小技巧，增加程序的健壮性。]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深度学习程序逻辑思考]]></title>
    <url>%2F2019%2F10%2F10%2F%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%A8%8B%E5%BA%8F%E9%80%BB%E8%BE%91%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[深度学习从读取数据算起，整个程序流程很复杂、环节很多。对于一些多次使用的方法，把它写成函数多次调用，这固然好，但是随着时间的推移，这些函数就成了一个个黑箱。再加上，错综复杂的调用越来越多，程序的逻辑越来越复杂，修改、调用、维护的难度不断增加。 我觉得我可以适量减少函数的使用，少量重复使用的可以再复制一遍，这样条理会清晰很多，修改会容易很多，修改时不用考虑对其他部分造成的影响。]]></content>
      <tags>
        <tag>深度学习</tag>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python调用迭代器里面的内容]]></title>
    <url>%2F2019%2F10%2F10%2Fpython%E8%B0%83%E7%94%A8%E8%BF%AD%E4%BB%A3%E5%99%A8%E9%87%8C%E9%9D%A2%E7%9A%84%E5%86%85%E5%AE%B9%2F</url>
    <content type="text"><![CDATA[迭代器 Iteraterpython要查看迭代器离得部分内容时，主要的有以下3种方法：(以查看第一个元素为例)1.for循环12345dev_iter &#x3D; build_iterator(dev_data, config)for i in dev_iter: if i: print(i) break 结果：123456789101112131415161718((tensor([[ 101, 1036, 4997, ..., 0, 0, 0], [ 101, 1036, 4997, ..., 0, 0, 0], [ 101, 1036, 4997, ..., 4851, 4289, 0], ..., [ 101, 4495, 3189, ..., 831, 1044, 1355], [ 101, 4495, 3189, ..., 7317, 7164, 7509], [ 101, 7922, 6235, ..., 6804, 1931, 0]], device&#x3D;&#39;cuda:0&#39;), tensor([25, 29, 31, 32, 32, 32, 32, 32, 32, 29, 32, 32, 29, 20, 32, 29, 32, 32, 30, 31, 31, 32, 31, 29, 32, 32, 32, 32, 28, 30, 30, 32, 32, 31, 27, 32, 31, 30, 31, 32, 30, 32, 29, 30, 31, 32, 27, 25, 29, 32, 32, 32, 31, 30, 30, 31, 31, 22, 32, 31, 29, 32, 32, 31], device&#x3D;&#39;cuda:0&#39;), tensor([[1, 1, 1, ..., 0, 0, 0], [1, 1, 1, ..., 0, 0, 0], [1, 1, 1, ..., 1, 1, 0], ..., [1, 1, 1, ..., 1, 1, 1], [1, 1, 1, ..., 1, 1, 1], [1, 1, 1, ..., 1, 1, 0]], device&#x3D;&#39;cuda:0&#39;)), tensor([8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 7, 7, 7, 7, 7, 7, 7, 7, 7, 4, 4, 4, 4, 4, 4, 4, 4, 4, 6], device&#x3D;&#39;cuda:0&#39;)) 2.生成式/生成器12dev_iter &#x3D; build_iterator(dev_data, config)[_ for _ in dev_iter][0] 结果：123456789101112131415161718192021((tensor([[ 101, 1036, 4997, ..., 0, 0, 0], [ 101, 1036, 4997, ..., 0, 0, 0], [ 101, 1036, 4997, ..., 4851, 4289, 0], ..., [ 101, 4495, 3189, ..., 831, 1044, 1355], [ 101, 4495, 3189, ..., 7317, 7164, 7509], [ 101, 7922, 6235, ..., 6804, 1931, 0]], device&#x3D;&#39;cuda:0&#39;), tensor([25, 29, 31, 32, 32, 32, 32, 32, 32, 29, 32, 32, 29, 20, 32, 29, 32, 32, 30, 31, 31, 32, 31, 29, 32, 32, 32, 32, 28, 30, 30, 32, 32, 31, 27, 32, 31, 30, 31, 32, 30, 32, 29, 30, 31, 32, 27, 25, 29, 32, 32, 32, 31, 30, 30, 31, 31, 22, 32, 31, 29, 32, 32, 31], device&#x3D;&#39;cuda:0&#39;), tensor([[1, 1, 1, ..., 0, 0, 0], [1, 1, 1, ..., 0, 0, 0], [1, 1, 1, ..., 1, 1, 0], ..., [1, 1, 1, ..., 1, 1, 1], [1, 1, 1, ..., 1, 1, 1], [1, 1, 1, ..., 1, 1, 0]], device&#x3D;&#39;cuda:0&#39;)), tensor([8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 7, 7, 7, 7, 7, 7, 7, 7, 7, 4, 4, 4, 4, 4, 4, 4, 4, 4, 6], device&#x3D;&#39;cuda:0&#39;)) 3.next()函数12dev_iter &#x3D; build_iterator(dev_data, config)next(dev_iter) 结果：123456789101112131415161718192021((tensor([[ 101, 1036, 4997, ..., 0, 0, 0], [ 101, 1036, 4997, ..., 0, 0, 0], [ 101, 1036, 4997, ..., 4851, 4289, 0], ..., [ 101, 4495, 3189, ..., 831, 1044, 1355], [ 101, 4495, 3189, ..., 7317, 7164, 7509], [ 101, 7922, 6235, ..., 6804, 1931, 0]], device&#x3D;&#39;cuda:0&#39;), tensor([25, 29, 31, 32, 32, 32, 32, 32, 32, 29, 32, 32, 29, 20, 32, 29, 32, 32, 30, 31, 31, 32, 31, 29, 32, 32, 32, 32, 28, 30, 30, 32, 32, 31, 27, 32, 31, 30, 31, 32, 30, 32, 29, 30, 31, 32, 27, 25, 29, 32, 32, 32, 31, 30, 30, 31, 31, 22, 32, 31, 29, 32, 32, 31], device&#x3D;&#39;cuda:0&#39;), tensor([[1, 1, 1, ..., 0, 0, 0], [1, 1, 1, ..., 0, 0, 0], [1, 1, 1, ..., 1, 1, 0], ..., [1, 1, 1, ..., 1, 1, 1], [1, 1, 1, ..., 1, 1, 1], [1, 1, 1, ..., 1, 1, 0]], device&#x3D;&#39;cuda:0&#39;)), tensor([8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 7, 7, 7, 7, 7, 7, 7, 7, 7, 4, 4, 4, 4, 4, 4, 4, 4, 4, 6], device&#x3D;&#39;cuda:0&#39;))]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为pytorch安装nvidia的apex加速]]></title>
    <url>%2F2019%2F10%2F10%2F%E4%B8%BApytorch%E5%AE%89%E8%A3%85nvidia%E7%9A%84apex%E5%8A%A0%E9%80%9F%2F</url>
    <content type="text"><![CDATA[三个指令，不需要配置环境变量123$ git clone https:&#x2F;&#x2F;github.com&#x2F;NVIDIA&#x2F;apex$ cd apex$ pip3 install -v --no-cache-dir --global-option&#x3D;&quot;--cpp_ext&quot; --global-option&#x3D;&quot;--cuda_ext&quot; .&#x2F;]]></content>
      <tags>
        <tag>pytorch</tag>
        <tag>nvidia</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo标题有空格 怎么办]]></title>
    <url>%2F2019%2F10%2F09%2Fhexo%E6%A0%87%E9%A2%98%E6%9C%89%E7%A9%BA%E6%A0%BC-%E6%80%8E%E4%B9%88%E5%8A%9E%2F</url>
    <content type="text"><![CDATA[输入标题时在引号内输入。如：1hexo n &quot;hexo标题 有空格 怎么办&quot;]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在终端下查看文件md5值]]></title>
    <url>%2F2019%2F10%2F09%2F%E5%9C%A8%E7%BB%88%E7%AB%AF%E4%B8%8B%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6md5%E5%80%BC%2F</url>
    <content type="text"><![CDATA[md5sum SwitchyOmega.crx直接md5sum 文件就可以了]]></content>
      <tags>
        <tag>linux</tag>
        <tag>md5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker-compose_up_-d定义和运行多个容器]]></title>
    <url>%2F2019%2F10%2F09%2Fdocker-compose-up-d%E5%AE%9A%E4%B9%89%E5%92%8C%E8%BF%90%E8%A1%8C%E5%A4%9A%E4%B8%AA%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[12docker-compose Define and run multi-container applications with Docker.up Create and start containers]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安装nextcloud_mysql数据库、数据持久版]]></title>
    <url>%2F2019%2F10%2F09%2F%E5%AE%89%E8%A3%85nextcloud-mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%81%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E7%89%88%2F</url>
    <content type="text"><![CDATA[1.保存以下为nextcloud.yml可以修改一下其中的密码和映射端口12345678910111213141516171819202122232425262728version: &#39;2&#39;volumes: nextcloud: db:services: db: image: mariadb command: --transaction-isolation&#x3D;READ-COMMITTED --binlog-format&#x3D;ROW restart: always volumes: - db:&#x2F;var&#x2F;lib&#x2F;mysql environment: - MYSQL_ROOT_PASSWORD&#x3D;123456 - MYSQL_PASSWORD&#x3D;123456 - MYSQL_DATABASE&#x3D;nextcloud - MYSQL_USER&#x3D;nextcloud app: image: nextcloud ports: - 8080:80 links: - db volumes: - nextcloud:&#x2F;var&#x2F;www&#x2F;html restart: always 2. apt install docker-compose3. docker-compose -f nextcloud.yml up -d4. 打开http://localhost:8081后的数据库配置1For the database use db as host and nextcloud as table and user name. Also enter the password you chose in your docker-compose.yml file. host 用db 就可以了 其他的输入对应的帐号密码。 5.此时使用ip不能访问。docker exec -it [容器id] baseapt updateapt install vimvim config/config.php在trusted_domains下添加 1 =&gt; ‘192.168.x.x:8080’保存即生效。]]></content>
      <tags>
        <tag>docker</tag>
        <tag>nextcloud</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iphone更新开了两步验证的appleid下载的应用]]></title>
    <url>%2F2019%2F10%2F09%2Fiphone%E6%9B%B4%E6%96%B0%E5%BC%80%E4%BA%86%E4%B8%A4%E6%AD%A5%E9%AA%8C%E8%AF%81%E7%9A%84appleid%E4%B8%8B%E8%BD%BD%E7%9A%84%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[输入密码后会有以后和设置两个选项。点设置。进去输一下手机验证码就可以了，不用切换apple id的。]]></content>
      <tags>
        <tag>iphone</tag>
        <tag>appleid</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker_runtime_nvidia找不到文件问题]]></title>
    <url>%2F2019%2F10%2F09%2Fdocker-runtime-nvidia%E6%89%BE%E4%B8%8D%E5%88%B0%E6%96%87%E4%BB%B6%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[https://github.com/NVIDIA/nvidia-docker 打开以上链接安装一下以下指令1234567891011121314151617# Add the package repositories$ distribution&#x3D;$(. &#x2F;etc&#x2F;os-release;echo $ID$VERSION_ID)$ curl -s -L https:&#x2F;&#x2F;nvidia.github.io&#x2F;nvidia-docker&#x2F;gpgkey | sudo apt-key add -$ curl -s -L https:&#x2F;&#x2F;nvidia.github.io&#x2F;nvidia-docker&#x2F;$distribution&#x2F;nvidia-docker.list | sudo tee &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;nvidia-docker.list$ sudo apt-get update &amp;&amp; sudo apt-get install -y nvidia-container-toolkit$ sudo systemctl restart docker# On debian based distributions: Ubuntu &#x2F; Debian$ sudo apt-get update$ sudo apt-get --only-upgrade install docker-ce nvidia-docker2$ sudo systemctl restart docker# All of the following options will continue working#$ docker run --gpus all nvidia&#x2F;cuda:9.0-base nvidia-smi$ docker run --runtime nvidia nvidia&#x2F;cuda:9.0-base nvidia-smi]]></content>
      <tags>
        <tag>docker</tag>
        <tag>nvidia</tag>
        <tag>cuda</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[服务器容易因gpu显存占满而卡死，那就尽量使用动态增长，牺牲一点性能也是可以的]]></title>
    <url>%2F2019%2F10%2F09%2F%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E6%98%93%E5%9B%A0gpu%E6%98%BE%E5%AD%98%E5%8D%A0%E6%BB%A1%E8%80%8C%E5%8D%A1%E6%AD%BB%EF%BC%8C%E9%82%A3%E5%B0%B1%E5%B0%BD%E9%87%8F%E4%BD%BF%E7%94%A8%E5%8A%A8%E6%80%81%E5%A2%9E%E9%95%BF%EF%BC%8C%E7%89%BA%E7%89%B2%E4%B8%80%E7%82%B9%E6%80%A7%E8%83%BD%E4%B9%9F%E6%98%AF%E5%8F%AF%E4%BB%A5%E7%9A%84%2F</url>
    <content type="text"><![CDATA[动态增长代码：123456import keras.backend.tensorflow_backend as KTFimport tensorflow as tfconfig &#x3D; tf.ConfigProto()config.gpu_options.allow_growth&#x3D;True sess &#x3D; tf.Session(config&#x3D;config)KTF.set_session(sess)]]></content>
      <tags>
        <tag>深度学习</tag>
        <tag>keras</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[当有些软件或库如keras新版本出现问题时]]></title>
    <url>%2F2019%2F10%2F09%2F%E5%BD%93%E6%9C%89%E4%BA%9B%E8%BD%AF%E4%BB%B6%E6%88%96%E5%BA%93%E5%A6%82keras%E6%96%B0%E7%89%88%E6%9C%AC%E5%87%BA%E7%8E%B0%E9%97%AE%E9%A2%98%E6%97%B6%2F</url>
    <content type="text"><![CDATA[如果反馈的及时，可能在github的master分支已经解决，通过github重新安装时一个不错的解决方式。还有，切记以后训练或使用某个模型时，记住当时的主要库的版本，之后在其他地方配置环境时，要直接指定版本号。]]></content>
      <tags>
        <tag>深度学习</tag>
        <tag>keras</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于hexo文中中标签的使用方法]]></title>
    <url>%2F2019%2F10%2F09%2F%E5%85%B3%E4%BA%8Ehexo%E6%96%87%E4%B8%AD%E4%B8%AD%E6%A0%87%E7%AD%BE%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[12345title: title #文章标题date: 2015-02-05 12:47:44 #文章生成时间categories: #文章分类目录 可以省略tags: #文章标签 可以省略description: #你对本页的描述 可以省略 多标签有两种方式：123456789tags:- 标签1- 标签2- 标签3- etc...和tags: [iOS,报错]并且标签下的文章越多，标签越大。]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo文章多标签]]></title>
    <url>%2F2019%2F10%2F09%2Fhexo%E6%96%87%E7%AB%A0%E5%A4%9A%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[在tags:后使用方括号，用英语逗号分开多个标签。如：[深度学习,jupyter]另外只有hexo new page tags生成标签页面，并配置source/tags/index.md文件后，页面上的标签个数对应的数字才能跳转，不然无响应。 另外2如果想在文章中使用时markdown语法的符号，需要把三个点和它同行。]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jupyter_notebook上程序导致显存占满卡死，无法关闭的情况]]></title>
    <url>%2F2019%2F10%2F09%2Fjupyter-notebook%E4%B8%8A%E7%A8%8B%E5%BA%8F%E5%AF%BC%E8%87%B4%E6%98%BE%E5%AD%98%E5%8D%A0%E6%BB%A1%E5%8D%A1%E6%AD%BB%EF%BC%8C%E6%97%A0%E6%B3%95%E5%85%B3%E9%97%AD%E7%9A%84%E6%83%85%E5%86%B5%2F</url>
    <content type="text"><![CDATA[1.当在jupyter notebook中调试程序导致程序无法关闭时，可以使用ps -aux|grep python来排查2.当发现多个和jupyter notebook相关的进程时，应该考虑进程号靠后的，靠前的时启动jupyter notebook程序的进程。kill -9 [进程号]后成功释放显存。如下图所示： 关于kill -9默认参数下，kill 发送SIGTERM（15）信号给进程，告诉进程，你需要被关闭，请自行停止运行并退出。kill -9 发送SIGKILL信号给进程，告诉进程，你被终结了，请立刻退出。因此 kill - 9 表示强制杀死该进程,同时接收这个信号的进程在收到这个信号时不能执行任何清理。 更新1nvidia-smi 哪个占的多kill -9 哪个]]></content>
      <tags>
        <tag>深度学习</tag>
        <tag>jupyter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo文章中添加图片功能]]></title>
    <url>%2F2019%2F10%2F09%2Fhexo%E6%96%87%E7%AB%A0%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%9B%BE%E7%89%87%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[1.修改根目录_config.yml:将post_asset_folder: false改为post_asset_folder: true2.安装插件:npm install https://github.com/CodeFalling/hexo-asset-image -- save 3.在运行hexo n创建新文章时会生成对应的文件夹，将图片放入文件夹。 4.使用 ![](图片名字.图片格式) 插入图片。 示例:]]></content>
  </entry>
  <entry>
    <title><![CDATA[将个人技术博客迁移到GitHub_Pages]]></title>
    <url>%2F2019%2F10%2F09%2F%E5%B0%86%E4%B8%AA%E4%BA%BA%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E5%88%B0GitHub-Pages%2F</url>
    <content type="text"><![CDATA[由于简书经常不可用，现将个人技术博客迁移到GitHub Pages，为了统一在一个地方，后续会做少量文章迁移。]]></content>
  </entry>
</search>
